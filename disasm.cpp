#include "stdafx.h"

#include "disasm.h"
#include <cmath>
#include <iostream>
#include <string>
#include <vector>

using namespace std;
using namespace disasm;

#pragma warning(disable:4996)

#define IS_FILE_ERROR( operation, goodState )	if( operation goodState ){	\
												SetError( ferror( pFile)); return false; }


////////####################################################################################
////////####################################################################################


	_i386Prefixes	_disasm::st_globalPrefixes[ 13] = 
	{
		{ 0xF0, 1, "LOCK"	},		// Lock and repeat prefixes
		{ 0xF2, 1, "REPNE"	},
		{ 0xF3, 1, "REPE"	},
		{ 0x2E,	2, "CS"		},		// Segment override prefixes
		{ 0x36, 2, "SS"		},
		{ 0x3E, 2, "DS"		},
		{ 0x26, 2, "ES"		},
		{ 0x64, 2, "FS"		},
		{ 0x65, 2, "GS"		},
		{ 0x2E, 2, ""		},		// Branch not taken (used only with Jcc instructions)
		{ 0x3E, 2, ""		},		// Branch taken (used only with Jcc instructions)
		{ 0x66, 3, ""		},		// Operand-size override prefix
		{ 0x67, 4, ""		}		// Address-size override prefix
	};

	// ==============================

	// Opcodes table, generated by own program. This app has parsed
	// "The Complete Pentium Instruction Set Table, by Sang Cho" text file,
	// and basing on it, application has generated below table.
	// Currently about 622 opcodes implemented (in table).
	_i386Opcode		_disasm::st_globalOpcodes [ 622 ] =
	{
		//stCode, ndCode, bData,bImmSize,NumArgs, Arguments,     Name
		{ _TWO(0x00, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"ADD" },
		{ _TWO(0x01, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"ADD" },
		{ _TWO(0x02, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"ADD" },
		{ _TWO(0x03, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"ADD" },
		{ _TWO(0x04, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"ADD" },
		{ _TWO(0x05, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"ADD" },
		{ _TWO(0x06, 0x00), 0xFF, NONE, 1, { ES, NONE, NONE },	"PUSH" },
		{ _TWO(0x07, 0x00), 0xFF, NONE, 1, { ES, NONE, NONE },	"POP" },
		{ _TWO(0x08, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"OR" },
		{ _TWO(0x09, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"OR" },
		{ _TWO(0x0A, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"OR" },
		{ _TWO(0x0B, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"OR" },
		{ _TWO(0x0C, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"OR" },
		{ _TWO(0x0D, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"OR" },
		{ _TWO(0x0E, 0x00), 0xFF, NONE, 1, { CS, NONE, NONE },	"PUSH" },
		{ _TWO(0x0F, 0x00), 0x00, NONE, 1, { R_M32, NONE, NONE },	"SLDT" },
		{ _TWO(0x0F, 0x00), 0x01, NONE, 1, { R_M16, NONE, NONE },	"STR" },
		{ _TWO(0x0F, 0x00), 0x02, NONE, 1, { R_M16, NONE, NONE },	"LLDT" },
		{ _TWO(0x0F, 0x00), 0x03, NONE, 1, { R_M16, NONE, NONE },	"LTR" },
		{ _TWO(0x0F, 0x00), 0x04, NONE, 1, { R_M16, NONE, NONE },	"VERR" },
		{ _TWO(0x0F, 0x00), 0x05, NONE, 1, { R_M16, NONE, NONE },	"VERW" },
		{ _TWO(0x0F, 0x01), 0x00, NONE, 1, { M, NONE, NONE },	"SGDT" },
		{ _TWO(0x0F, 0x01), 0x01, NONE, 1, { M, NONE, NONE },	"SIDT" },
		{ _TWO(0x0F, 0x01), 0x02, NONE, 1, { M16_32, NONE, NONE },	"LGDT" },
		{ _TWO(0x0F, 0x01), 0x03, NONE, 1, { M16_32, NONE, NONE },	"LIDT" },
		{ _TWO(0x0F, 0x01), 0x04, NONE, 1, { R_M32, NONE, NONE },	"SMSW" },
		{ _TWO(0x0F, 0x01), 0x06, NONE, 1, { R_M16, NONE, NONE },	"LMSW" },
		{ _TWO(0x0F, 0x01), 0x07, NONE, 1, { M, NONE, NONE },	"INVLPG" },
		{ _TWO(0x0F, 0x02), 0x10, NONE, 2, { R32, R_M32, NONE },	"LAR" },
		{ _TWO(0x0F, 0x03), 0x10, NONE, 2, { R16, R_M16, NONE },	"LSL" },
		{ _TWO(0x0F, 0x03), 0x10, NONE, 2, { R32, R_M32, NONE },	"LSL" },
		{ _TWO(0x0F, 0x06), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CLTS" },
		{ _TWO(0x0F, 0x08), 0xFF, NONE, 0, { NONE, NONE, NONE },	"INVD" },
		{ _TWO(0x0F, 0x09), 0xFF, NONE, 0, { NONE, NONE, NONE },	"WBINVD" },
		{ _TWO(0x0F, 0x0B), 0xFF, NONE, 0, { NONE, NONE, NONE },	"UD2" },
		{ _TWO(0x0F, 0x20), 0x10, NONE, 2, { R32, CR0, NONE },	"MOV" },
		{ _TWO(0x0F, 0x20), 0x10, NONE, 2, { R32, CR2, NONE },	"MOV" },
		{ _TWO(0x0F, 0x20), 0x10, NONE, 2, { R32, CR3, NONE },	"MOV" },
		{ _TWO(0x0F, 0x20), 0x10, NONE, 2, { R32, CR4, NONE },	"MOV" },
		{ _TWO(0x0F, 0x21), 0x10, NONE, 2, { R32, DR0, NONE },	"MOV" },
		{ _TWO(0x0F, 0x22), 0x10, NONE, 2, { CR0, R32, NONE },	"MOV" },
		{ _TWO(0x0F, 0x22), 0x10, NONE, 2, { CR2, R32, NONE },	"MOV" },
		{ _TWO(0x0F, 0x22), 0x10, NONE, 2, { CR3, R32, NONE },	"MOV" },
		{ _TWO(0x0F, 0x22), 0x10, NONE, 2, { CR4, R32, NONE },	"MOV" },
		{ _TWO(0x0F, 0x23), 0x10, NONE, 2, { DR0, R32, NONE },	"MOV" },
		{ _TWO(0x0F, 0x30), 0xFF, NONE, 0, { NONE, NONE, NONE },	"WRMSR" },
		{ _TWO(0x0F, 0x31), 0xFF, NONE, 0, { NONE, NONE, NONE },	"RDTSC" },
		{ _TWO(0x0F, 0x32), 0xFF, NONE, 0, { NONE, NONE, NONE },	"RDMSR" },
		{ _TWO(0x0F, 0x33), 0xFF, NONE, 0, { NONE, NONE, NONE },	"RDPMC" },
		{ _TWO(0x0F, 0x40), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVO" },
		{ _TWO(0x0F, 0x41), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNO" },
		{ _TWO(0x0F, 0x42), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVB" },
		{ _TWO(0x0F, 0x42), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVC" },
		{ _TWO(0x0F, 0x42), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNAE" },
		{ _TWO(0x0F, 0x43), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVAE" },
		{ _TWO(0x0F, 0x43), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNB" },
		{ _TWO(0x0F, 0x43), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNC" },
		{ _TWO(0x0F, 0x44), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVE" },
		{ _TWO(0x0F, 0x44), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVZ" },
		{ _TWO(0x0F, 0x45), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNE" },
		{ _TWO(0x0F, 0x45), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNZ" },
		{ _TWO(0x0F, 0x46), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVBE" },
		{ _TWO(0x0F, 0x46), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNA" },
		{ _TWO(0x0F, 0x47), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVA" },
		{ _TWO(0x0F, 0x47), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNBE" },
		{ _TWO(0x0F, 0x48), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVS" },
		{ _TWO(0x0F, 0x49), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNS" },
		{ _TWO(0x0F, 0x4A), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVP" },
		{ _TWO(0x0F, 0x4A), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVPE" },
		{ _TWO(0x0F, 0x4B), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNP" },
		{ _TWO(0x0F, 0x4B), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVPO" },
		{ _TWO(0x0F, 0x4C), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVL" },
		{ _TWO(0x0F, 0x4C), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNGE" },
		{ _TWO(0x0F, 0x4D), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVGE" },
		{ _TWO(0x0F, 0x4D), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNL" },
		{ _TWO(0x0F, 0x4E), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVLE" },
		{ _TWO(0x0F, 0x4E), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNG" },
		{ _TWO(0x0F, 0x4F), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVG" },
		{ _TWO(0x0F, 0x4F), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMOVNLE" },
		{ _TWO(0x0F, 0x60), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PUNPCKLBW" },
		{ _TWO(0x0F, 0x61), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PUNPCKLWD" },
		{ _TWO(0x0F, 0x62), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PUNPCKLDQ" },
		{ _TWO(0x0F, 0x63), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PACKSSWB" },
		{ _TWO(0x0F, 0x64), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PCMPGTB" },
		{ _TWO(0x0F, 0x65), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PCMPGTW" },
		{ _TWO(0x0F, 0x66), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PCMPGTD" },
		{ _TWO(0x0F, 0x67), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PACKUSWB" },
		{ _TWO(0x0F, 0x68), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PUNPCKHBW" },
		{ _TWO(0x0F, 0x69), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PUNPCKHWD" },
		{ _TWO(0x0F, 0x6A), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PUNPCKHDQ" },
		{ _TWO(0x0F, 0x6B), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PACKSSDW" },
		{ _TWO(0x0F, 0x6E), 0x10, NONE, 2, { MM, R_M32, NONE },	"MOVD" },
		{ _TWO(0x0F, 0x6F), 0x10, NONE, 2, { MM, MM_M64, NONE },	"MOVQ" },
		{ _TWO(0x0F, 0x71), 0x02, SIZE_BYTE, 2, { MM, IMM8, NONE },	"PSRLW" },
		{ _TWO(0x0F, 0x71), 0x04, SIZE_BYTE, 2, { MM, IMM8, NONE },	"PSRAW" },
		{ _TWO(0x0F, 0x71), 0x06, SIZE_BYTE, 2, { MM, IMM8, NONE },	"PSLLW" },
		{ _TWO(0x0F, 0x72), 0x02, SIZE_BYTE, 2, { MM, IMM8, NONE },	"PSRLD" },
		{ _TWO(0x0F, 0x72), 0x04, SIZE_BYTE, 2, { MM, IMM8, NONE },	"PSRAD" },
		{ _TWO(0x0F, 0x72), 0x06, SIZE_BYTE, 2, { MM, IMM8, NONE },	"PSLLD" },
		{ _TWO(0x0F, 0x73), 0x02, SIZE_BYTE, 2, { MM, IMM8, NONE },	"PSRLQ" },
		{ _TWO(0x0F, 0x73), 0x06, SIZE_BYTE, 2, { MM, IMM8, NONE },	"PSLLQ" },
		{ _TWO(0x0F, 0x74), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PCMPEQB" },
		{ _TWO(0x0F, 0x75), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PCMPEQW" },
		{ _TWO(0x0F, 0x76), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PCMPEQD" },
		{ _TWO(0x0F, 0x77), 0xFF, NONE, 0, { NONE, NONE, NONE },	"EMMS" },
		{ _TWO(0x0F, 0x7E), 0x10, NONE, 2, { R_M32, MM, NONE },	"MOVD" },
		{ _TWO(0x0F, 0x7F), 0x10, NONE, 2, { MM_M64, MM, NONE },	"MOVQ" },
		{ _TWO(0x0F, 0x80), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JO" },
		{ _TWO(0x0F, 0x81), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JNO" },
		{ _TWO(0x0F, 0x82), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JB" },
		{ _TWO(0x0F, 0x83), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JAE" },
		{ _TWO(0x0F, 0x84), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JE" },
		{ _TWO(0x0F, 0x85), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JNE" },
		{ _TWO(0x0F, 0x86), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JBE" },
		{ _TWO(0x0F, 0x87), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JA" },
		{ _TWO(0x0F, 0x88), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JS" },
		{ _TWO(0x0F, 0x89), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JNS" },
		{ _TWO(0x0F, 0x8A), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JPE" },
		{ _TWO(0x0F, 0x8B), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JPO" },
		{ _TWO(0x0F, 0x8C), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JL" },
		{ _TWO(0x0F, 0x8D), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JGE" },
		{ _TWO(0x0F, 0x8E), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JLE" },
		{ _TWO(0x0F, 0x8F), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JG" },
		{ _TWO(0x0F, 0x90), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETO" },
		{ _TWO(0x0F, 0x91), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETNO" },
		{ _TWO(0x0F, 0x92), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETB" },
		{ _TWO(0x0F, 0x93), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETAE" },
		{ _TWO(0x0F, 0x94), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETE" },
		{ _TWO(0x0F, 0x95), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETNE" },
		{ _TWO(0x0F, 0x96), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETBE" },
		{ _TWO(0x0F, 0x97), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETA" },
		{ _TWO(0x0F, 0x98), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETS" },
		{ _TWO(0x0F, 0x99), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETNS" },
		{ _TWO(0x0F, 0x9A), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETPE" },
		{ _TWO(0x0F, 0x9B), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETPO" },
		{ _TWO(0x0F, 0x9C), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETL" },
		{ _TWO(0x0F, 0x9D), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETGE" },
		{ _TWO(0x0F, 0x9E), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETLE" },
		{ _TWO(0x0F, 0x9F), 0x10, NONE, 1, { R_M8, NONE, NONE },	"SETG" },
		{ _TWO(0x0F, 0xA0), 0xFF, NONE, 1, { FS, NONE, NONE },	"PUSH" },
		{ _TWO(0x0F, 0xA1), 0xFF, NONE, 1, { FS, NONE, NONE },	"POP" },
		{ _TWO(0x0F, 0xA2), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CPUID" },
		{ _TWO(0x0F, 0xA3), 0x10, NONE, 2, { R_M32, R32, NONE },	"BT" },
		{ _TWO(0x0F, 0xA4), 0x10, SIZE_BYTE, 3, { R_M32, R32, IMM8 },	"SHLD" },
		{ _TWO(0x0F, 0xA5), 0x10, NONE, 3, { R_M32, R32, CL },	"" },
		{ _TWO(0x0F, 0xA8), 0xFF, NONE, 1, { GS, NONE, NONE },	"PUSH" },
		{ _TWO(0x0F, 0xA9), 0xFF, NONE, 1, { GS, NONE, NONE },	"POP" },
		{ _TWO(0x0F, 0xAA), 0xFF, NONE, 0, { NONE, NONE, NONE },	"RSM" },
		{ _TWO(0x0F, 0xAB), 0x10, NONE, 2, { R_M32, R32, NONE },	"BTS" },
		{ _TWO(0x0F, 0xAC), 0x10, SIZE_BYTE, 3, { R_M32, R32, IMM8 },	"SHRD" },
		{ _TWO(0x0F, 0xAD), 0x10, NONE, 3, { R_M32, R32, CL },	"" },
		{ _TWO(0x0F, 0xAF), 0x10, NONE, 2, { R32, R_M32, NONE },	"IMUL" },
		{ _TWO(0x0F, 0xB0), 0x10, NONE, 2, { R_M8, R8, NONE },	"CMPXCHG" },
		{ _TWO(0x0F, 0xB1), 0x10, NONE, 2, { R_M32, R32, NONE },	"CMPXCHG" },
		{ _TWO(0x0F, 0xB2), 0x10, NONE, 2, { R32, M16_32, NONE },	"LSS" },
		{ _TWO(0x0F, 0xB3), 0x10, NONE, 2, { R_M32, R32, NONE },	"BTR" },
		{ _TWO(0x0F, 0xB4), 0x10, NONE, 2, { R32, M16_32, NONE },	"LFS" },
		{ _TWO(0x0F, 0xB5), 0x10, NONE, 2, { R32, M16_32, NONE },	"LGS" },
		{ _TWO(0x0F, 0xB6), 0x10, NONE, 2, { R32, R_M8, NONE },	"MOVZX" },
		{ _TWO(0x0F, 0xB7), 0x10, NONE, 2, { R32, R_M16, NONE },	"MOVZX" },
		{ _TWO(0x0F, 0xBA), 0x04, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"BT" },
		{ _TWO(0x0F, 0xBA), 0x05, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"BTS" },
		{ _TWO(0x0F, 0xBA), 0x06, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"BTR" },
		{ _TWO(0x0F, 0xBA), 0x07, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"BTC" },
		{ _TWO(0x0F, 0xBB), 0x10, NONE, 2, { R_M32, R32, NONE },	"BTC" },
		{ _TWO(0x0F, 0xBC), 0x10, NONE, 2, { R32, R_M32, NONE },	"BSF" },
		{ _TWO(0x0F, 0xBD), 0x10, NONE, 2, { R32, R_M32, NONE },	"BSR" },
		{ _TWO(0x0F, 0xBE), 0x10, NONE, 2, { R32, R_M8, NONE },	"MOVSX" },
		{ _TWO(0x0F, 0xBF), 0x10, NONE, 2, { R32, R_M16, NONE },	"MOVSX" },
		{ _TWO(0x0F, 0xC0), 0x10, NONE, 2, { R_M8, R8, NONE },	"XADD" },
		{ _TWO(0x0F, 0xC1), 0x10, NONE, 2, { R_M16, R16, NONE },	"XADD" },
		{ _TWO(0x0F, 0xC1), 0x10, NONE, 2, { R_M32, R32, NONE },	"XADD" },
		{ _TWO(0x0F, 0xC7), 0x01, NONE, 1, { M64, NONE, NONE },	"CMPXCHG8B" },
		{ _TWO(0x0F, 0xC8), 0x50, SIZE_DWORD, 1, { R32, NONE, NONE },	"BSWAP" },
		{ _TWO(0x0F, 0xD1), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSRLW" },
		{ _TWO(0x0F, 0xD2), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSRLD" },
		{ _TWO(0x0F, 0xD3), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSRLQ" },
		{ _TWO(0x0F, 0xD5), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PMULLW" },
		{ _TWO(0x0F, 0xD8), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSUBUSB" },
		{ _TWO(0x0F, 0xD9), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSUBUSW" },
		{ _TWO(0x0F, 0xDB), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PAND" },
		{ _TWO(0x0F, 0xDC), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PADDUSB" },
		{ _TWO(0x0F, 0xDD), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PADDUSW" },
		{ _TWO(0x0F, 0xDF), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PANDN" },
		{ _TWO(0x0F, 0xE1), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSRAW" },
		{ _TWO(0x0F, 0xE2), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSRAD" },
		{ _TWO(0x0F, 0xE5), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PMULHW" },
		{ _TWO(0x0F, 0xE8), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSUBSB" },
		{ _TWO(0x0F, 0xE9), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSUBSW" },
		{ _TWO(0x0F, 0xEB), 0x10, NONE, 2, { MM, MM_M64, NONE },	"POR" },
		{ _TWO(0x0F, 0xEC), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PADDSB" },
		{ _TWO(0x0F, 0xED), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PADDSW" },
		{ _TWO(0x0F, 0xEF), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PXOR" },
		{ _TWO(0x0F, 0xF1), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSLLW" },
		{ _TWO(0x0F, 0xF2), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSLLD" },
		{ _TWO(0x0F, 0xF3), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSLLQ" },
		{ _TWO(0x0F, 0xF5), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PMADDWD" },
		{ _TWO(0x0F, 0xF8), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSUBB" },
		{ _TWO(0x0F, 0xF9), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSUBW" },
		{ _TWO(0x0F, 0xFA), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PSUBD" },
		{ _TWO(0x0F, 0xFC), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PADDB" },
		{ _TWO(0x0F, 0xFD), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PADDW" },
		{ _TWO(0x0F, 0xFE), 0x10, NONE, 2, { MM, MM_M64, NONE },	"PADDD" },
		{ _TWO(0x10, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"ADC" },
		{ _TWO(0x11, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"ADC" },
		{ _TWO(0x12, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"ADC" },
		{ _TWO(0x13, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"ADC" },
		{ _TWO(0x14, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"ADC" },
		{ _TWO(0x15, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"ADC" },
		{ _TWO(0x16, 0x00), 0xFF, NONE, 1, { SS, NONE, NONE },	"PUSH" },
		{ _TWO(0x17, 0x00), 0xFF, NONE, 1, { SS, NONE, NONE },	"POP" },
		{ _TWO(0x18, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"SBB" },
		{ _TWO(0x19, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"SBB" },
		{ _TWO(0x1A, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"SBB" },
		{ _TWO(0x1B, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"SBB" },
		{ _TWO(0x1C, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"SBB" },
		{ _TWO(0x1D, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"SBB" },
		{ _TWO(0x1E, 0x00), 0xFF, NONE, 1, { DS, NONE, NONE },	"PUSH" },
		{ _TWO(0x1F, 0x00), 0xFF, NONE, 1, { DS, NONE, NONE },	"POP" },
		{ _TWO(0x20, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"AND" },
		{ _TWO(0x21, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"AND" },
		{ _TWO(0x22, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"AND" },
		{ _TWO(0x23, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"AND" },
		{ _TWO(0x24, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"AND" },
		{ _TWO(0x25, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"AND" },
		{ _TWO(0x27, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"DAA" },
		{ _TWO(0x28, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"SUB" },
		{ _TWO(0x29, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"SUB" },
		{ _TWO(0x2A, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"SUB" },
		{ _TWO(0x2B, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"SUB" },
		{ _TWO(0x2C, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"SUB" },
		{ _TWO(0x2D, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"SUB" },
		{ _TWO(0x2F, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"DAS" },
		{ _TWO(0x30, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"XOR" },
		{ _TWO(0x31, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"XOR" },
		{ _TWO(0x32, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"XOR" },
		{ _TWO(0x33, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"XOR" },
		{ _TWO(0x34, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"XOR" },
		{ _TWO(0x35, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"XOR" },
		{ _TWO(0x37, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"AAA" },
		{ _TWO(0x38, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"CMP" },
		{ _TWO(0x39, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"CMP" },
		{ _TWO(0x3A, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"CMP" },
		{ _TWO(0x3B, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"CMP" },
		{ _TWO(0x3C, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"CMP" },
		{ _TWO(0x3D, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"CMP" },
		{ _TWO(0x3F, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"AAS" },
		{ _TWO(0x40, 0x00), 0x50, SIZE_DWORD, 1, { R32, NONE, NONE },	"INC" },
		{ _TWO(0x48, 0x00), 0x50, SIZE_DWORD, 1, { R32, NONE, NONE },	"DEC" },
		{ _TWO(0x50, 0x00), 0x50, SIZE_DWORD, 1, { R32, NONE, NONE },	"PUSH" },
		{ _TWO(0x58, 0x00), 0x50, SIZE_DWORD, 1, { R32, NONE, NONE },	"POP" },
		{ _TWO(0x60, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"PUSHAD" },
		{ _TWO(0x61, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"POPAD" },
		{ _TWO(0x62, 0x00), 0x10, NONE, 2, { R32, M32_32, NONE },	"BOUND" },
		{ _TWO(0x63, 0x00), 0x10, NONE, 2, { R_M16, R16, NONE },	"ARPL" },
		{ _TWO(0x68, 0x00), 0xFF, SIZE_DWORD, 1, { IMM32, NONE, NONE },	"PUSH" },
		{ _TWO(0x69, 0x00), 0x10, SIZE_DWORD, 2, { R32, IMM32, NONE },	"IMUL" },
		{ _TWO(0x69, 0x00), 0x10, SIZE_DWORD, 3, { R32, R_M32, IMM32 },	"IMUL" },
		{ _TWO(0x6A, 0x00), 0xFF, SIZE_BYTE, 1, { IMM8, NONE, NONE },	"PUSH" },
		{ _TWO(0x6B, 0x00), 0x10, SIZE_BYTE, 2, { R32, IMM8, NONE },	"IMUL" },
		{ _TWO(0x6B, 0x00), 0x10, SIZE_BYTE, 3, { R32, R_M32, IMM8 },	"IMUL" },
		{ _TWO(0x6C, 0x00), 0xFF, NONE, 1, { M8, NONE, NONE },	"INS" },
		{ _TWO(0x6D, 0x00), 0xFF, NONE, 1, { M32, NONE, NONE },	"INS" },
		{ _TWO(0x6E, 0x00), 0xFF, NONE, 2, { DX, M8, NONE },	"OUTS" },
		{ _TWO(0x6F, 0x00), 0xFF, NONE, 2, { DX, M32, NONE },	"OUTS" },
		{ _TWO(0x70, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JO" },
		{ _TWO(0x71, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JNO" },
		{ _TWO(0x72, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JC" },
		{ _TWO(0x73, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JAE" },
		{ _TWO(0x74, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JE" },
		{ _TWO(0x75, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JNE" },
		{ _TWO(0x76, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JBE" },
		{ _TWO(0x77, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JA" },
		{ _TWO(0x78, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JS" },
		{ _TWO(0x79, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JNS" },
		{ _TWO(0x7A, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JPE" },
		{ _TWO(0x7B, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JPO" },
		{ _TWO(0x7C, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JL" },
		{ _TWO(0x7D, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JGE" },
		{ _TWO(0x7E, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JLE" },
		{ _TWO(0x7F, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JG" },
		{ _TWO(0x80, 0x00), 0x00, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"ADD" },
		{ _TWO(0x80, 0x00), 0x01, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"OR" },
		{ _TWO(0x80, 0x00), 0x02, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"ADC" },
		{ _TWO(0x80, 0x00), 0x03, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"SBB" },
		{ _TWO(0x80, 0x00), 0x04, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"AND" },
		{ _TWO(0x80, 0x00), 0x05, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"SUB" },
		{ _TWO(0x80, 0x00), 0x06, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"XOR" },
		{ _TWO(0x80, 0x00), 0x07, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"CMP" },
		{ _TWO(0x81, 0x00), 0x00, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"ADD" },
		{ _TWO(0x81, 0x00), 0x01, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"OR" },
		{ _TWO(0x81, 0x00), 0x02, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"ADC" },
		{ _TWO(0x81, 0x00), 0x03, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"SBB" },
		{ _TWO(0x81, 0x00), 0x04, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"AND" },
		{ _TWO(0x81, 0x00), 0x05, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"SUB" },
		{ _TWO(0x81, 0x00), 0x06, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"XOR" },
		{ _TWO(0x81, 0x00), 0x07, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"CMP" },
		{ _TWO(0x83, 0x00), 0x00, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"ADD" },
		{ _TWO(0x83, 0x00), 0x01, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"OR" },
		{ _TWO(0x83, 0x00), 0x02, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"ADC" },
		{ _TWO(0x83, 0x00), 0x03, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"SBB" },
		{ _TWO(0x83, 0x00), 0x04, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"AND" },
		{ _TWO(0x83, 0x00), 0x05, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"SUB" },
		{ _TWO(0x83, 0x00), 0x06, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"XOR" },
		{ _TWO(0x83, 0x00), 0x07, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"CMP" },
		{ _TWO(0x84, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"TEST" },
		{ _TWO(0x85, 0x00), 0x10, NONE, 2, { R_M16, R16, NONE },	"TEST" },
		{ _TWO(0x85, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"TEST" },
		{ _TWO(0x86, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"XCHG" },
		{ _TWO(0x86, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"XCHG" },
		{ _TWO(0x87, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"XCHG" },
		{ _TWO(0x87, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"XCHG" },
		{ _TWO(0x88, 0x00), 0x10, NONE, 2, { R_M8, R8, NONE },	"MOV" },
		{ _TWO(0x89, 0x00), 0x10, NONE, 2, { R_M32, R32, NONE },	"MOV" },
		{ _TWO(0x8A, 0x00), 0x10, NONE, 2, { R8, R_M8, NONE },	"MOV" },
		{ _TWO(0x8B, 0x00), 0x10, NONE, 2, { R32, R_M32, NONE },	"MOV" },
		{ _TWO(0x8C, 0x00), 0x10, NONE, 2, { R_M16, SREG, NONE },	"MOV" },
		{ _TWO(0x8D, 0x00), 0x10, NONE, 2, { R32, M, NONE },	"LEA" },
		{ _TWO(0x8E, 0x00), 0x10, NONE, 2, { SREG, R_M16, NONE },	"MOV" },
		{ _TWO(0x8F, 0x00), 0x00, NONE, 1, { M32, NONE, NONE },	"POP" },
		{ _TWO(0x90, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"NOP" },
		{ _TWO(0x90, 0x00), 0x50, SIZE_DWORD, 2, { EAX, R32, NONE },	"XCHG" },
		{ _TWO(0x90, 0x00), 0x50, SIZE_DWORD, 2, { R32, EAX, NONE },	"XCHG" },
		{ _TWO(0x98, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CBW" },
		{ _TWO(0x99, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CDQ" },
		{ _TWO(0x99, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CWD" },
		{ _TWO(0x9A, 0x00), 0xFF, JMP_FAR, 1, { PTR16_32, NONE, NONE },	"CALL" },
		{ _TWO(0x9B, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FWAIT" },
		{ _TWO(0x9B, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"WAIT" },
		{ _TWO(0x9B, 0xD9), 0x06, NONE, 1, { M14_28BYTE, NONE, NONE },	"FSTENV" },
		{ _TWO(0x9B, 0xD9), 0x07, NONE, 1, { M2BYTE, NONE, NONE },	"FSTCW" },
		{ _TWO(0x9B, 0xDB), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FCLEX" },
		{ _TWO(0x9B, 0xDB), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FINIT" },
		{ _TWO(0x9B, 0xDD), 0x06, NONE, 2, { M94_108BYTE, NONE, NONE },	"FSAVE" },
		{ _TWO(0x9B, 0xDD), 0x07, NONE, 1, { M2BYTE, NONE, NONE },	"FSTSW" },
		{ _TWO(0x9B, 0xDF), 0xFF, NONE, 1, { AX, NONE, NONE },	"FSTSW" },
		{ _TWO(0x9C, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"PUSHFD" },
		{ _TWO(0x9D, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"POPFD" },
		{ _TWO(0x9E, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"SAHF" },
		{ _TWO(0x9F, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"LAHF" },
		{ _TWO(0xA0, 0x00), 0xFF, NONE, 2, { AL, MOFFS8, NONE },	"MOV" },
		{ _TWO(0xA1, 0x00), 0xFF, NONE, 2, { AX, MOFFS16, NONE },	"MOV" },
		{ _TWO(0xA1, 0x00), 0xFF, NONE, 2, { EAX, MOFFS32, NONE },	"MOV" },
		{ _TWO(0xA2, 0x00), 0xFF, NONE, 2, { MOFFS8, AL, NONE },	"MOV" },
		{ _TWO(0xA3, 0x00), 0xFF, NONE, 2, { MOFFS16, AX, NONE },	"MOV" },
		{ _TWO(0xA3, 0x00), 0xFF, NONE, 2, { MOFFS32, EAX, NONE },	"MOV" },
		{ _TWO(0xA4, 0x00), 0xFF, NONE, 2, { M8, M8, NONE },	"MOVS" },
		{ _TWO(0xA5, 0x00), 0xFF, NONE, 2, { M32, M32, NONE },	"MOVS" },
		{ _TWO(0xA6, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CMPSB" },
		{ _TWO(0xA7, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CMPSD" },
		{ _TWO(0xA8, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"TEST" },
		{ _TWO(0xA9, 0x00), 0xFF, SIZE_DWORD, 2, { EAX, IMM32, NONE },	"TEST" },
		{ _TWO(0xAA, 0x00), 0xFF, NONE, 1, { M8, NONE, NONE },	"STOS" },
		{ _TWO(0xAB, 0x00), 0xFF, NONE, 1, { M32, NONE, NONE },	"STOS" },
		{ _TWO(0xAC, 0x00), 0xFF, NONE, 1, { M8, NONE, NONE },	"LODS" },
		{ _TWO(0xAD, 0x00), 0xFF, NONE, 1, { M32, NONE, NONE },	"LODS" },
		{ _TWO(0xAE, 0x00), 0xFF, NONE, 1, { M8, NONE, NONE },	"SCAS" },
		{ _TWO(0xAF, 0x00), 0xFF, NONE, 1, { M32, NONE, NONE },	"SCAS" },
		{ _TWO(0xB0, 0x00), 0x50, SIZE_BYTE, 2, { R8, IMM8, NONE },	"MOV" },
		{ _TWO(0xB8, 0x00), 0x50, SIZE_DWORD, 2, { R32, IMM32, NONE },	"MOV" },
		{ _TWO(0xC0, 0x00), 0x00, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"ROL" },
		{ _TWO(0xC0, 0x00), 0x01, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"ROR" },
		{ _TWO(0xC0, 0x00), 0x02, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"RCL" },
		{ _TWO(0xC0, 0x00), 0x03, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"RCR" },
		{ _TWO(0xC0, 0x00), 0x04, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"SAL" },
		{ _TWO(0xC0, 0x00), 0x04, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"SHL" },
		{ _TWO(0xC0, 0x00), 0x05, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"SHR" },
		{ _TWO(0xC0, 0x00), 0x07, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"SAR" },
		{ _TWO(0xC1, 0x00), 0x00, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"ROL" },
		{ _TWO(0xC1, 0x00), 0x01, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"ROR" },
		{ _TWO(0xC1, 0x00), 0x02, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"RCL" },
		{ _TWO(0xC1, 0x00), 0x03, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"RCR" },
		{ _TWO(0xC1, 0x00), 0x04, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"SAL" },
		{ _TWO(0xC1, 0x00), 0x04, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"SHL" },
		{ _TWO(0xC1, 0x00), 0x05, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"SHR" },
		{ _TWO(0xC1, 0x00), 0x07, SIZE_BYTE, 2, { R_M32, IMM8, NONE },	"SAR" },
		{ _TWO(0xC2, 0x00), 0xFF, SIZE_WORD, 1, { IMM16, NONE, NONE },	"RET" },
		{ _TWO(0xC3, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"RET" },
		{ _TWO(0xC4, 0x00), 0x10, NONE, 2, { R32, M16_32, NONE },	"LES" },
		{ _TWO(0xC5, 0x00), 0x10, NONE, 2, { R32, M16_32, NONE },	"LDS" },
		{ _TWO(0xC6, 0x00), 0x00, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"MOV" },
		{ _TWO(0xC7, 0x00), 0x00, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"MOV" },
		{ _TWO(0xC8, 0x00), 0xFF, NONE, 2, { IMM16, 0, NONE },	"ENTER" },
		{ _TWO(0xC8, 0x00), 0xFF, NONE, 2, { IMM16, 1, NONE },	"ENTER" },
		{ _TWO(0xC8, 0x00), 0xFF, NONE, 2, { IMM16, IMM8, NONE },	"ENTER" },
		{ _TWO(0xC9, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"LEAVE" },
		{ _TWO(0xCA, 0x00), 0xFF, SIZE_WORD, 1, { IMM16, NONE, NONE },	"RET" },
		{ _TWO(0xCB, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"RET" },
		{ _TWO(0xCC, 0x00), 0xFF, NONE, 1, { 3, NONE, NONE },	"RET 3" },
		{ _TWO(0xCD, 0x00), 0xFF, SIZE_BYTE, 1, { IMM8, NONE, NONE },	"INT" },
		{ _TWO(0xCE, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"INTO" },
		{ _TWO(0xCF, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"IRETD" },
		{ _TWO(0xD0, 0x00), 0x00, NONE, 2, { R_M8, 1, NONE },	"ROL" },
		{ _TWO(0xD0, 0x00), 0x01, NONE, 2, { R_M8, 1, NONE },	"ROR" },
		{ _TWO(0xD0, 0x00), 0x02, NONE, 2, { R_M8, 1, NONE },	"RCL" },
		{ _TWO(0xD0, 0x00), 0x03, NONE, 2, { R_M8, 1, NONE },	"RCR" },
		{ _TWO(0xD0, 0x00), 0x04, NONE, 2, { R_M8, 1, NONE },	"SAL" },
		{ _TWO(0xD0, 0x00), 0x04, NONE, 2, { R_M8, 1, NONE },	"SHL" },
		{ _TWO(0xD0, 0x00), 0x05, NONE, 2, { R_M8, 1, NONE },	"SHR" },
		{ _TWO(0xD0, 0x00), 0x07, NONE, 2, { R_M8, 1, NONE },	"SAR" },
		{ _TWO(0xD1, 0x00), 0x00, NONE, 2, { R_M32, 1, NONE },	"ROL" },
		{ _TWO(0xD1, 0x00), 0x01, NONE, 2, { R_M32, 1, NONE },	"ROR" },
		{ _TWO(0xD1, 0x00), 0x02, NONE, 2, { R_M32, 1, NONE },	"RCL" },
		{ _TWO(0xD1, 0x00), 0x03, NONE, 2, { R_M32, 1, NONE },	"RCR" },
		{ _TWO(0xD1, 0x00), 0x04, NONE, 2, { R_M32, 1, NONE },	"SAL" },
		{ _TWO(0xD1, 0x00), 0x04, NONE, 2, { R_M32, 1, NONE },	"SHL" },
		{ _TWO(0xD1, 0x00), 0x05, NONE, 2, { R_M32, 1, NONE },	"SHR" },
		{ _TWO(0xD1, 0x00), 0x07, NONE, 2, { R_M32, 1, NONE },	"SAR" },
		{ _TWO(0xD2, 0x00), 0x00, NONE, 2, { R_M8, CL, NONE },	"ROL" },
		{ _TWO(0xD2, 0x00), 0x01, NONE, 2, { R_M8, CL, NONE },	"ROR" },
		{ _TWO(0xD2, 0x00), 0x02, NONE, 2, { R_M8, CL, NONE },	"RCL" },
		{ _TWO(0xD2, 0x00), 0x03, NONE, 2, { R_M8, CL, NONE },	"RCR" },
		{ _TWO(0xD2, 0x00), 0x04, NONE, 2, { R_M8, CL, NONE },	"SAL" },
		{ _TWO(0xD2, 0x00), 0x04, NONE, 2, { R_M8, CL, NONE },	"SHL" },
		{ _TWO(0xD2, 0x00), 0x05, NONE, 2, { R_M8, CL, NONE },	"SHR" },
		{ _TWO(0xD2, 0x00), 0x07, NONE, 2, { R_M8, CL, NONE },	"SAR" },
		{ _TWO(0xD3, 0x00), 0x00, NONE, 2, { R_M32, CL, NONE },	"ROL" },
		{ _TWO(0xD3, 0x00), 0x01, NONE, 2, { R_M32, CL, NONE },	"ROR" },
		{ _TWO(0xD3, 0x00), 0x02, NONE, 2, { R_M32, CL, NONE },	"RCL" },
		{ _TWO(0xD3, 0x00), 0x03, NONE, 2, { R_M32, CL, NONE },	"RCR" },
		{ _TWO(0xD3, 0x00), 0x04, NONE, 2, { R_M32, CL, NONE },	"SAL" },
		{ _TWO(0xD3, 0x00), 0x04, NONE, 2, { R_M32, CL, NONE },	"SHL" },
		{ _TWO(0xD3, 0x00), 0x05, NONE, 2, { R_M32, CL, NONE },	"SHR" },
		{ _TWO(0xD3, 0x00), 0x07, NONE, 2, { R_M32, CL, NONE },	"SAR" },
		{ _TWO(0xD4, 0x0A), 0xFF, NONE, 0, { NONE, NONE, NONE },	"AAM" },
		{ _TWO(0xD5, 0x0A), 0xFF, NONE, 0, { NONE, NONE, NONE },	"AAD" },
		{ _TWO(0xD6, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"SETALC" },
		{ _TWO(0xD7, 0x00), 0xFF, NONE, 1, { M8, NONE, NONE },	"XLAT" },
		{ _TWO(0xD8, 0x00), 0x00, NONE, 1, { M32REAL, NONE, NONE },	"FADD" },
		{ _TWO(0xD8, 0x00), 0x01, NONE, 1, { M32REAL, NONE, NONE },	"FMUL" },
		{ _TWO(0xD8, 0x00), 0x02, NONE, 1, { M32REAL, NONE, NONE },	"FCOM" },
		{ _TWO(0xD8, 0x00), 0x03, NONE, 1, { M32REAL, NONE, NONE },	"FCOMP" },
		{ _TWO(0xD8, 0x00), 0x04, NONE, 1, { M32REAL, NONE, NONE },	"FSUB" },
		{ _TWO(0xD8, 0x00), 0x05, NONE, 1, { M32REAL, NONE, NONE },	"FSUBR" },
		{ _TWO(0xD8, 0x00), 0x06, NONE, 1, { M32REAL, NONE, NONE },	"FDIV" },
		{ _TWO(0xD8, 0x00), 0x07, NONE, 1, { M32REAL, NONE, NONE },	"FDIVR" },
		{ _TWO(0xD8, 0xC0), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FADD" },
		{ _TWO(0xD8, 0xC8), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FMUL" },
		{ _TWO(0xD8, 0xD0), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FCOM" },
		{ _TWO(0xD8, 0xD1), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FCOM" },
		{ _TWO(0xD8, 0xD8), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FCOMP" },
		{ _TWO(0xD8, 0xD9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FCOMP" },
		{ _TWO(0xD8, 0xE0), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FSUB" },
		{ _TWO(0xD8, 0xE8), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FSUBR" },
		{ _TWO(0xD8, 0xF0), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FDIV" },
		{ _TWO(0xD8, 0xF8), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FDIVR" },
		{ _TWO(0xD9, 0x00), 0x00, NONE, 1, { M32REAL, NONE, NONE },	"FLD" },
		{ _TWO(0xD9, 0x00), 0x02, NONE, 1, { M32REAL, NONE, NONE },	"FST" },
		{ _TWO(0xD9, 0x00), 0x03, NONE, 1, { M32REAL, NONE, NONE },	"FSTP" },
		{ _TWO(0xD9, 0x00), 0x04, NONE, 1, { M14_28BYTE, NONE, NONE },	"FLDENV" },
		{ _TWO(0xD9, 0x00), 0x05, NONE, 1, { M2BYTE, NONE, NONE },	"FLDCW" },
		{ _TWO(0xD9, 0x00), 0x06, NONE, 1, { M14_28BYTE, NONE, NONE },	"FNSTENV" },
		{ _TWO(0xD9, 0x00), 0x07, NONE, 1, { M2BYTE, NONE, NONE },	"FNSTCW" },
		{ _TWO(0xD9, 0xC0), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FLD" },
		{ _TWO(0xD9, 0xC8), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FXCH" },
		{ _TWO(0xD9, 0xC9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FXCH" },
		{ _TWO(0xD9, 0xD0), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FNOP" },
		{ _TWO(0xD9, 0xE0), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FCHS" },
		{ _TWO(0xD9, 0xE1), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FABS" },
		{ _TWO(0xD9, 0xE4), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FTST" },
		{ _TWO(0xD9, 0xE5), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FXAM" },
		{ _TWO(0xD9, 0xE8), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FLD1" },
		{ _TWO(0xD9, 0xE9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FLDL2T" },
		{ _TWO(0xD9, 0xEA), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FLDL2E" },
		{ _TWO(0xD9, 0xEB), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FLDPI" },
		{ _TWO(0xD9, 0xEC), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FLDLG2" },
		{ _TWO(0xD9, 0xED), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FLDLN2" },
		{ _TWO(0xD9, 0xEE), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FLDZ" },
		{ _TWO(0xD9, 0xF0), 0xFF, NONE, 0, { NONE, NONE, NONE },	"F2XM1" },
		{ _TWO(0xD9, 0xF1), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FYL2X" },
		{ _TWO(0xD9, 0xF2), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FPTAN" },
		{ _TWO(0xD9, 0xF3), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FPATAN" },
		{ _TWO(0xD9, 0xF4), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FXTRACT" },
		{ _TWO(0xD9, 0xF5), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FPREM1" },
		{ _TWO(0xD9, 0xF6), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FDECSTP" },
		{ _TWO(0xD9, 0xF7), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FINCSTP" },
		{ _TWO(0xD9, 0xF8), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FPREM" },
		{ _TWO(0xD9, 0xF9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FYL2XP1" },
		{ _TWO(0xD9, 0xFA), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FSQRT" },
		{ _TWO(0xD9, 0xFB), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FSINCOS" },
		{ _TWO(0xD9, 0xFC), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FRNDINT" },
		{ _TWO(0xD9, 0xFD), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FSCALE" },
		{ _TWO(0xD9, 0xFE), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FSIN" },
		{ _TWO(0xD9, 0xFF), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FCOS" },
		{ _TWO(0xDA, 0x00), 0x00, NONE, 1, { M32INT, NONE, NONE },	"FIADD" },
		{ _TWO(0xDA, 0x00), 0x01, NONE, 1, { M32INT, NONE, NONE },	"FIMUL" },
		{ _TWO(0xDA, 0x00), 0x02, NONE, 1, { M32INT, NONE, NONE },	"FICOM" },
		{ _TWO(0xDA, 0x00), 0x03, NONE, 1, { M32INT, NONE, NONE },	"FICOMP" },
		{ _TWO(0xDA, 0x00), 0x04, NONE, 1, { M32INT, NONE, NONE },	"FISUB" },
		{ _TWO(0xDA, 0x00), 0x05, NONE, 1, { M32INT, NONE, NONE },	"FISUBR" },
		{ _TWO(0xDA, 0x00), 0x06, NONE, 1, { M32INT, NONE, NONE },	"FIDIV" },
		{ _TWO(0xDA, 0x00), 0x07, NONE, 1, { M32INT, NONE, NONE },	"FIDIVR" },
		{ _TWO(0xDA, 0xC0), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FCMOVB" },
		{ _TWO(0xDA, 0xC8), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FCMOVE" },
		{ _TWO(0xDA, 0xD0), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FCMOVBE" },
		{ _TWO(0xDA, 0xD8), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FCMOVU" },
		{ _TWO(0xDA, 0xE9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FUCOMPP" },
		{ _TWO(0xDB, 0x00), 0x00, NONE, 1, { M32INT, NONE, NONE },	"FILD" },
		{ _TWO(0xDB, 0x00), 0x02, NONE, 1, { M32INT, NONE, NONE },	"FIST" },
		{ _TWO(0xDB, 0x00), 0x03, NONE, 1, { M32INT, NONE, NONE },	"FISTP" },
		{ _TWO(0xDB, 0x00), 0x05, NONE, 1, { M80REAL, NONE, NONE },	"FLD" },
		{ _TWO(0xDB, 0x00), 0x07, NONE, 1, { M80REAL, NONE, NONE },	"FSTP" },
		{ _TWO(0xDB, 0xC0), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FCMOVNB" },
		{ _TWO(0xDB, 0xC8), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FCMOVNE" },
		{ _TWO(0xDB, 0xD0), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FCMOVNBE" },
		{ _TWO(0xDB, 0xD8), 0xFF, NONE, 2, { ST_0_, ST_I_, NONE },	"FCMOVNU" },
		{ _TWO(0xDB, 0xE2), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FNCLEX" },
		{ _TWO(0xDB, 0xE3), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FNINIT" },
		{ _TWO(0xDB, 0xE8), 0xFF, NONE, 2, { ST, ST_I_, NONE },	"FUCOMI" },
		{ _TWO(0xDB, 0xF0), 0xFF, NONE, 2, { ST, ST_I_, NONE },	"FCOMI" },
		{ _TWO(0xDC, 0x00), 0x00, NONE, 1, { M64REAL, NONE, NONE },	"FADD" },
		{ _TWO(0xDC, 0x00), 0x01, NONE, 1, { M64REAL, NONE, NONE },	"FMUL" },
		{ _TWO(0xDC, 0x00), 0x02, NONE, 1, { M64REAL, NONE, NONE },	"FCOM" },
		{ _TWO(0xDC, 0x00), 0x03, NONE, 1, { M64REAL, NONE, NONE },	"FCOMP" },
		{ _TWO(0xDC, 0x00), 0x04, NONE, 1, { M64REAL, NONE, NONE },	"FSUB" },
		{ _TWO(0xDC, 0x00), 0x05, NONE, 1, { M64REAL, NONE, NONE },	"FSUBR" },
		{ _TWO(0xDC, 0x00), 0x06, NONE, 1, { M64REAL, NONE, NONE },	"FDIV" },
		{ _TWO(0xDC, 0x00), 0x07, NONE, 1, { M64REAL, NONE, NONE },	"FDIVR" },
		{ _TWO(0xDC, 0xC0), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FADD" },
		{ _TWO(0xDC, 0xC8), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FMUL" },
		{ _TWO(0xDC, 0xE0), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FSUBR" },
		{ _TWO(0xDC, 0xE8), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FSUB" },
		{ _TWO(0xDC, 0xF0), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FDIVR" },
		{ _TWO(0xDC, 0xF8), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FDIV" },
		{ _TWO(0xDD, 0x00), 0x00, NONE, 1, { M64REAL, NONE, NONE },	"FLD" },
		{ _TWO(0xDD, 0x00), 0x02, NONE, 1, { M64REAL, NONE, NONE },	"FST" },
		{ _TWO(0xDD, 0x00), 0x03, NONE, 1, { M64REAL, NONE, NONE },	"FSTP" },
		{ _TWO(0xDD, 0x00), 0x04, NONE, 2, { M94_108BYTE, NONE, NONE },	"FRSTOR" },
		{ _TWO(0xDD, 0x00), 0x06, NONE, 2, { M94_108BYTE, NONE, NONE },	"FNSAVE" },
		{ _TWO(0xDD, 0x00), 0x07, NONE, 1, { M2BYTE, NONE, NONE },	"FNSTSW" },
		{ _TWO(0xDD, 0xC0), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FFREE" },
		{ _TWO(0xDD, 0xD0), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FST" },
		{ _TWO(0xDD, 0xD8), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FSTP" },
		{ _TWO(0xDD, 0xE0), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FUCOM" },
		{ _TWO(0xDD, 0xE1), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FUCOM" },
		{ _TWO(0xDD, 0xE8), 0xFF, NONE, 1, { ST_I_, NONE, NONE },	"FUCOMP" },
		{ _TWO(0xDD, 0xE9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FUCOMP" },
		{ _TWO(0xDE, 0x00), 0x00, NONE, 1, { M16INT, NONE, NONE },	"FIADD" },
		{ _TWO(0xDE, 0x00), 0x01, NONE, 1, { M16INT, NONE, NONE },	"FIMUL" },
		{ _TWO(0xDE, 0x00), 0x02, NONE, 1, { M16INT, NONE, NONE },	"FICOM" },
		{ _TWO(0xDE, 0x00), 0x03, NONE, 1, { M16INT, NONE, NONE },	"FICOMP" },
		{ _TWO(0xDE, 0x00), 0x04, NONE, 1, { M16INT, NONE, NONE },	"FISUB" },
		{ _TWO(0xDE, 0x00), 0x05, NONE, 1, { M16INT, NONE, NONE },	"FISUBR" },
		{ _TWO(0xDE, 0x00), 0x06, NONE, 1, { M16INT, NONE, NONE },	"FIDIV" },
		{ _TWO(0xDE, 0x00), 0x07, NONE, 1, { M16INT, NONE, NONE },	"FIDIVR" },
		{ _TWO(0xDE, 0xC0), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FADDP" },
		{ _TWO(0xDE, 0xC1), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FADDP" },
		{ _TWO(0xDE, 0xC8), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FMULP" },
		{ _TWO(0xDE, 0xC9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FMULP" },
		{ _TWO(0xDE, 0xD9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FCOMPP" },
		{ _TWO(0xDE, 0xE0), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FSUBRP" },
		{ _TWO(0xDE, 0xE1), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FSUBRP" },
		{ _TWO(0xDE, 0xE8), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FSUBP" },
		{ _TWO(0xDE, 0xE9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FSUBP" },
		{ _TWO(0xDE, 0xF0), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FDIVRP" },
		{ _TWO(0xDE, 0xF1), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FDIVRP" },
		{ _TWO(0xDE, 0xF8), 0xFF, NONE, 2, { ST_I_, ST_0_, NONE },	"FDIVP" },
		{ _TWO(0xDE, 0xF9), 0xFF, NONE, 0, { NONE, NONE, NONE },	"FDIVP" },
		{ _TWO(0xDF, 0x00), 0x00, NONE, 1, { M16INT, NONE, NONE },	"FILD" },
		{ _TWO(0xDF, 0x00), 0x02, NONE, 1, { M16INT, NONE, NONE },	"FIST" },
		{ _TWO(0xDF, 0x00), 0x03, NONE, 1, { M16INT, NONE, NONE },	"FISTP" },
		{ _TWO(0xDF, 0x00), 0x04, NONE, 1, { M80BCD, NONE, NONE },	"FBLD" },
		{ _TWO(0xDF, 0x00), 0x05, NONE, 1, { M64INT, NONE, NONE },	"FILD" },
		{ _TWO(0xDF, 0x00), 0x06, NONE, 1, { M80BCD, NONE, NONE },	"FBSTP" },
		{ _TWO(0xDF, 0x00), 0x07, NONE, 1, { M64INT, NONE, NONE },	"FISTP" },
		{ _TWO(0xDF, 0xE0), 0xFF, NONE, 1, { AX, NONE, NONE },	"FNSTSW" },
		{ _TWO(0xDF, 0xE8), 0xFF, NONE, 2, { ST, ST_I_, NONE },	"FUCOMIP" },
		{ _TWO(0xDF, 0xF0), 0xFF, NONE, 2, { ST, ST_I_, NONE },	"FCOMIP" },
		{ _TWO(0xE0, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"LOOPNE" },
		{ _TWO(0xE0, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"LOOPNZ" },
		{ _TWO(0xE1, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"LOOPE" },
		{ _TWO(0xE1, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"LOOPZ" },
		{ _TWO(0xE2, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"LOOP" },
		{ _TWO(0xE3, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JECXZ" },
		{ _TWO(0xE4, 0x00), 0xFF, SIZE_BYTE, 2, { AL, IMM8, NONE },	"IN" },
		{ _TWO(0xE5, 0x00), 0xFF, SIZE_BYTE, 2, { EAX, IMM8, NONE },	"IN" },
		{ _TWO(0xE6, 0x00), 0xFF, SIZE_BYTE, 2, { IMM8, AL, NONE },	"OUT" },
		{ _TWO(0xE7, 0x00), 0xFF, SIZE_BYTE, 2, { IMM8, EAX, NONE },	"OUT" },
		{ _TWO(0xE8, 0x00), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"CALL" },
		{ _TWO(0xE9, 0x00), 0xFF, JMP_DWORD, 1, { REL32, NONE, NONE },	"JMP" },
		{ _TWO(0xEA, 0x00), 0xFF, JMP_FAR, 1, { PTR16_32, NONE, NONE },	"JMP" },
		{ _TWO(0xEB, 0x00), 0xFF, JMP_BYTE, 1, { REL8, NONE, NONE },	"JMP" },
		{ _TWO(0xEC, 0x00), 0xFF, NONE, 2, { AL, DX, NONE },	"IN" },
		{ _TWO(0xED, 0x00), 0xFF, NONE, 2, { EAX, DX, NONE },	"IN" },
		{ _TWO(0xEE, 0x00), 0xFF, NONE, 2, { DX, AL, NONE },	"OUT" },
		{ _TWO(0xEF, 0x00), 0xFF, NONE, 2, { DX, EAX, NONE },	"OUT" },
		{ _TWO(0xF1, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"INT1" },
		{ _TWO(0xF4, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"HLT" },
		{ _TWO(0xF5, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CMC" },
		{ _TWO(0xF6, 0x00), 0x02, NONE, 1, { R_M8, NONE, NONE },	"NOT" },
		{ _TWO(0xF6, 0x00), 0x03, NONE, 1, { R_M8, NONE, NONE },	"NEG" },
		{ _TWO(0xF6, 0x00), 0x04, NONE, 1, { R_M8, NONE, NONE },	"MUL" },
		{ _TWO(0xF6, 0x00), 0x05, NONE, 1, { R_M8, NONE, NONE },	"IMUL" },
		{ _TWO(0xF6, 0x00), 0x06, NONE, 1, { R_M8, NONE, NONE },	"DIV" },
		{ _TWO(0xF6, 0x00), 0x07, NONE, 1, { R_M8, NONE, NONE },	"IDIV" },
		{ _TWO(0xF6, 0x00), 0x00, SIZE_BYTE, 2, { R_M8, IMM8, NONE },	"TEST" },
		{ _TWO(0xF7, 0x00), 0x02, NONE, 1, { R_M32, NONE, NONE },	"NOT" },
		{ _TWO(0xF7, 0x00), 0x03, NONE, 1, { R_M32, NONE, NONE },	"NEG" },
		{ _TWO(0xF7, 0x00), 0x04, NONE, 1, { R_M32, NONE, NONE },	"MUL" },
		{ _TWO(0xF7, 0x00), 0x05, NONE, 1, { R_M32, NONE, NONE },	"IMUL" },
		{ _TWO(0xF7, 0x00), 0x06, NONE, 1, { R_M32, NONE, NONE },	"DIV" },
		{ _TWO(0xF7, 0x00), 0x06, NONE, 1, { R_M32, NONE, NONE },	"DIV" },
		{ _TWO(0xF7, 0x00), 0x07, NONE, 1, { R_M32, NONE, NONE },	"IDIV" },
		{ _TWO(0xF7, 0x00), 0x00, SIZE_DWORD, 2, { R_M32, IMM32, NONE },	"TEST" },
		{ _TWO(0xF8, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CLC" },
		{ _TWO(0xF9, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"STC" },
		{ _TWO(0xFA, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CLI" },
		{ _TWO(0xFB, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"STI" },
		{ _TWO(0xFC, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"CLD" },
		{ _TWO(0xFD, 0x00), 0xFF, NONE, 0, { NONE, NONE, NONE },	"STD" },
		{ _TWO(0xFE, 0x00), 0x00, NONE, 1, { R_M8, NONE, NONE },	"INC" },
		{ _TWO(0xFE, 0x00), 0x01, NONE, 1, { R_M8, NONE, NONE },	"DEC" },
		{ _TWO(0xFF, 0x00), 0x00, NONE, 1, { R_M32, NONE, NONE },	"INC" },
		{ _TWO(0xFF, 0x00), 0x01, NONE, 1, { R_M32, NONE, NONE },	"DEC" },
		{ _TWO(0xFF, 0x00), 0x02, NONE, 1, { R_M32, NONE, NONE },	"CALL" },
		{ _TWO(0xFF, 0x00), 0x03, NONE, 1, { M16_32, NONE, NONE },	"CALL" },
		{ _TWO(0xFF, 0x00), 0x04, NONE, 1, { R_M32, NONE, NONE },	"JMP" },
		{ _TWO(0xFF, 0x00), 0x06, NONE, 1, { R_M32, NONE, NONE },	"PUSH" },
		{ _TWO(0xFF, 0x00), 0x10, NONE, 1, { M16_32, NONE, NONE },	"JMP" },

		{ _TWO(0xFF, 0xFD), 0xFF, SIZE_BYTE, 1, { IMM8, NONE, NONE },	"DB" },
		{ _TWO(0xFF, 0xFE), 0xFF, SIZE_WORD, 1, { IMM16, NONE, NONE },	"DW" },
		{ _TWO(0xFF, 0xFF), 0xFF, SIZE_DWORD,1, { IMM32, NONE, NONE },	"DD" }

	};


	// 70-7F && E3,E9-EB -> One byte jumps
	#define __JUMPCODES1_ARRAY_SIZE	20
	BYTE			_disasm::st_globalJumpCodes1[ __JUMPCODES1_ARRAY_SIZE ] = {
		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
		0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
		0xE3, 0xE9, 0xEA, 0xEB
	};

	// 0F (80-8F)	- > two bytes jumps
	#define __JUMPCODES2_ARRAY_SIZE	16
	BYTE			_disasm::st_globalJumpCodes2[ __JUMPCODES2_ARRAY_SIZE ][2] = {
		{0x0F, 0x80}, {0x0F, 0x81}, {0x0F, 0x82}, {0x0F, 0x83}, 
		{0x0F, 0x84}, {0x0F, 0x85}, {0x0F, 0x86}, {0x0F, 0x87}, 
		{0x0F, 0x88}, {0x0F, 0x89}, {0x0F, 0x8A}, {0x0F, 0x8B}, 
		{0x0F, 0x8C}, {0x0F, 0x8D}, {0x0F, 0x8E}, {0x0F, 0x8F}		
	};

////////####################################################################################
////////####################################################################################

void	_disasm::_InitializeGlobals()
{
	pOpcodes = st_globalOpcodes;
	pPrefixes = st_globalPrefixes;
	uPrefixes = sizeof st_globalPrefixes / sizeof _i386Prefixes;
	uOpcodes = sizeof st_globalOpcodes / sizeof _i386Opcode;
}


bool	_disasm::Load( char *_szFileName)
{
	pFile = fopen( _szFileName, "rb");
	
	IS_FILE_ERROR( pFile, == NULL )
	if( peFile.LoadFile( _szFileName ) == FALSE )
	{ 
		SetError( peFile.GetError()); 
		return false; 
	}
	
	szFileName = (char*)peFile.szFileName;

	_disasm::_InitializeGlobals();

	return true;
}


_i386Opcode* 
		_disasm::GetOpcodeEx( LPBYTE lpBuffer )
{
	int	iSpecial = 0;
	unsigned uTmp = 0;

	if( lpBuffer[ 0] == 0x0F ||	(	lpBuffer[ 0] >= 0xD8 && lpBuffer[ 0] <= 0xDF ) )	
		iSpecial = 1;

	while( IsPrefix( lpBuffer[ uTmp] ) ) uTmp++;		// Skipping prefixes

	for( unsigned u = 0; u < uOpcodes; u++){
		if( iSpecial == 0)	{	
			if(		 lpBuffer[ uTmp]	== pOpcodes[ u].bCode[ 0])
				if( (lpBuffer[ uTmp] == pOpcodes[ u+1].bCode[ 0]) && (pOpcodes[ u].bData <= 0x10) )	
				{	// More than one opcode owns this code
					// Check to which group this opcode belongs. Compare ModRM.
					
					union {
						BYTE b;
						_i386ModRM mod;
					};

					b = (BYTE)lpBuffer[uTmp+GetOpcodeBytesNumber(&pOpcodes[u])];

					// Comparing ModRM byte to identify valid opcode
					if( mod.RegOp < 0x10 && mod.RegOp == pOpcodes[u].bData )
						return &pOpcodes[ u];
					else if( pOpcodes[u].bData == 0x10 )
					{
						// ModRM == 0x10 - "/r" switch - dunno what to do with that
						if( pOpcodes[ u].uArgC != 0)
						{
							if( GET_SIZE(pOpcodes[u].uArgs[0]) == SIZE_DWORD)
								return &pOpcodes[ u];
							if( GET_SIZE(pOpcodes[u].uArgs[1]) == SIZE_DWORD)
								return &pOpcodes[ u];
							if( GET_SIZE(pOpcodes[u].uArgs[2]) == SIZE_DWORD)
								return &pOpcodes[ u];
						}
					}else{
						_asm{
							nop
						}
					}
				}
				else		// Opcode belongs to instructions group, but is not different than others,
							// because has not ModRM byte (ModRM == 0xFF ). This is special case.
				{
					if( IsUsingRegister( &pOpcodes[u] ) )
					{
						unsigned short uReg = 0;
						if( IsRegister( pOpcodes[u].uArgs[0] ) ) uReg = pOpcodes[u].uArgs[0];
						else if( IsRegister( pOpcodes[u].uArgs[1] ) ) uReg = pOpcodes[u].uArgs[1];
						else if( IsRegister( pOpcodes[u].uArgs[2] ) ) uReg = pOpcodes[u].uArgs[2];

						// SUPPORTING ONLY 32bit mode computers !
						if( uReg != 0)
							if( GET_REGISTER_SIZE( uReg) != SIZE_DWORD )
								continue;
							else return &pOpcodes[ u];
						else return &pOpcodes[ u];
					}else return &pOpcodes[ u];
				}
		}else{
			if( (lpBuffer[ uTmp]	== pOpcodes[ u].bCode[ 0])
			&&	(lpBuffer[ uTmp+1]	== pOpcodes[ u].bCode[ 1]) ){
				return &pOpcodes[ u];
			}
		}
	}
	
	if( IsEscape( lpBuffer[ uTmp]) )	return GetOpcode( lpBuffer[ uTmp], lpBuffer[ uTmp+1] );
	else /* Not escape instruction */	return GetOpcode( lpBuffer[ uTmp] );
}

_i386Opcode* 
		_disasm::GetOpcode( BYTE bCode1, BYTE bCode2 )
{
	for( unsigned u = 0; u < uOpcodes; u++)
		if( bCode1 == pOpcodes[ u].bCode[ 0] &&	bCode2 == pOpcodes[ u].bCode[ 1] )
			return &pOpcodes[ u];

	return NULL;
}



////////####################################################################################

unsigned 
		_disasm::DisasmBytes( LPVOID _lpBuffer, PDISM lpDisasm, 
							 unsigned long uNumOfBytes, unsigned long uNumOfInstr )
{
	char	szLine[ 512]		= "";
	char	szPrefixes[ 4][ 16];
	char	szOpcode[ 16]		= "";
	char	szParams[ 3][64];
	char	szTmp[ 64]			= "";
	BYTE	*lpBuffer			= (BYTE*)_lpBuffer;

	lpWorkBuffer				= _lpBuffer;

	unsigned	uTmp					= 0, 
				uCounter				= 0, 
				uEndCount				= 0,
				uProcessedInstructions	= 0;
	bool		bCountInstructions		= false;


	if( lpBuffer == NULL || lpDisasm == NULL ||			// Validating passed arguments
		(uNumOfBytes == 0 && uNumOfInstr == 0) )
	{
		SetError( ERROR_BAD_ARGUMENTS);
		return -1;
	}
	
	if( uNumOfBytes != 0)								// Count bytes
	{ 
		uEndCount = uNumOfBytes; 
		bCountInstructions = false; 
	}
	else if( uNumOfInstr != 0 && uNumOfBytes == 0)		// Count instructions
	{ 
		uEndCount = uNumOfInstr; 
		bCountInstructions = true; 
	}

	memset( szPrefixes, 0, 64);
	memset( szParams, 0, 192 );

	PDISM	pDism = &lpDisasm[0];


	// Loop which iterates on next bytes of buffer, and parsing instructions
	while( uCounter < uEndCount )
	{
		//memset( (void*)pDism->szAdditional, 0, sizeof pDism->szAdditional );
		//memset( (void*)pDism->szParameters, 0, sizeof pDism->szParameters );
		//memset( (void*)pDism->szPrefixes, 0, sizeof pDism->szPrefixes );
		//memset( (void*)pDism->Instruction, 0, sizeof pDism->Instruction );
		memset( (void*)(pDism), 0, sizeof( DISM) );
		
		_i386Opcode *pOpc = NULL;
		for( unsigned b = 0; b < 4; b++)
			if( IsPrefix((BYTE)lpBuffer[ uTmp+b] ) )
				pDism->Instruction.Prefixes[ pDism->Instruction.NumOfPrefixes++] = 
									GetPrefix( (BYTE)lpBuffer[ uTmp+b] );
			else break;

		uTmp += pDism->Instruction.NumOfPrefixes;
		pOpc = GetOpcodeEx( &lpBuffer[ uTmp] );

		// Preparing structure...
		pDism->Instruction.NumOfBytes = 
			GetInstrBytesQuanity( (LPVOID)(DWORD(lpBuffer)+uTmp)) 
			+ pDism->Instruction.NumOfPrefixes;

		// Checking if according to quanity of bytes of this instruction there is
		// necessity to stop disassembling and rest bytes as free bytes ( DB, DW, DD)
		// to not disassemble instruction in half (to avoid possibility of insufficient
		// for instruction bytes number )
		if( !bCountInstructions )
			if( pDism->Instruction.NumOfBytes > (uEndCount-uCounter) )
			{
				uProcessedInstructions += 
					__DisassembleAsData( &lpBuffer[uTmp], pDism, (uEndCount-uCounter), uTmp, false );
				break;
			}

		// Copying instruction bytes
		memcpy( (void*)pDism->Instruction.cInstrBytes, 
				(const void*)(DWORD(lpBuffer) + uTmp - pDism->Instruction.NumOfPrefixes), 
				pDism->Instruction.NumOfBytes );

		// RAW address of an instruction counted from buffer zero address
		pDism->dwInstrAddress	=	uTmp + DWORD(_lpBuffer) - pDism->Instruction.NumOfPrefixes;
		pDism->dwRelativeAddr	=	uTmp - pDism->Instruction.NumOfPrefixes;

		// Checking for REGistry dependency
		if( IsRegDependent( (BYTE)lpBuffer[ uTmp], (BYTE)lpBuffer[ uTmp+1] ) )
		{
			// REG-Dependent instruction.
			
			if( lpBuffer[ uTmp] == 0x0F )
			{
				// 0F C8+rd instruction BSWAP exception
				lpDisasm[ uProcessedInstructions].szInstruction = GetOpcode( 0x0F, 0xC8)->szName;
				sprintf_s( pDism->szParameters[0], sizeof pDism->szParameters[0], 
							"%s", GetRegister( (BYTE)lpBuffer[ uTmp+1]-0xC8, SIZE_DWORD ) );
				pDism->Instruction.Opcode		= GetOpcode( 0x0F, 0xC8);
			}else
			{						// Rest of reg-dependent instruction
				unsigned u;
				for( u = 0; u < 8; u++ )
					if( GetOpcode( (BYTE)lpBuffer[ uTmp]-u) != NULL)
						if( GetOpcode( (BYTE)lpBuffer[ uTmp]-u)->bData == 0x50 ) break;

				pOpc = GetOpcode( (BYTE)lpBuffer[ uTmp]-u );
				_ASSERT( pOpc != NULL);

				pDism->szInstruction = pOpc->szName;
				pDism->Instruction.Opcode		= pOpc;
				if( pOpc->uArgC == 1)
					sprintf_s( pDism->szParameters[0], sizeof pDism->szParameters[0], 
							"%s", GetRegister( u, pOpc->bImmSize ) );
				else
					__PrepareDism( pOpc, &lpBuffer[uTmp], pDism, true);
			}			
		}else						// Instruction is not REG-Dependent.
		{
			if( pOpc == NULL)
			{
				// Unknown instruction (BYTE)
				if(	isprint(lpBuffer[ uTmp]) )
					sprintf( pDism->szAdditional,	"%X == '%c'", (BYTE)lpBuffer[ uTmp] );
				sprintf_s( pDism->szParameters[0], "%Xh", (BYTE)lpBuffer[ uTmp] );

				pDism->szInstruction				= GetOpcode( 0xFF, 0xFD )->szName;
				pDism->Instruction.bIsModRM			= 0;
				pDism->Instruction.wNOP				= 1;
				
				pDism->Instruction.cInstrBytes[0]	= (BYTE)lpBuffer[ uTmp];
			}else
			{
				if( pOpc->bData != 0xFF )
				{
					if( (pOpc->bData >= 0 && pOpc->bData <= 7) || pOpc->bData == 0x10 )
					{
						if( pOpc->bData >= 0 && pOpc->bData <= 7 )
						{
							// Opcode belongs to a group, so in a next byte, ModR/M, member
							// Reg/Operand contains a number of a group. Let's extract it.
							unsigned n = (pOpc->bCode[1] != 0)? 2 : 1;
							BYTE	sGroup = ((BYTE(lpBuffer[ uTmp+n]) & 0x38) >> 3);
							_i386Opcode	*_pOpc = pOpc;
							
							// searching for opcode with specified code and group.
							for( unsigned u = 0; u < 8; u++, _pOpc++){
								if( _pOpc->bCode[ 0] == (BYTE)lpBuffer[ uTmp]){
									if( pOpc->bCode[1] != 0 ){
										if( _pOpc->bData == sGroup 
											&& _pOpc->bCode[1] == pOpc->bCode[1] ){
											pOpc = _pOpc;
											break;						// We have our Opcode
										}
									}else{
										if( _pOpc->bData == sGroup ){
											pOpc = _pOpc;
											break;						// We have our Opcode
										}
									}
								}
							}
						}	// Group specyfing
					}

					// Instruction has "/r" switch - bData == 0x10. Need to parse it because of ModRM/SIB bytes
					__PrepareDism(	pOpc, (LPVOID)&lpBuffer[ uTmp], pDism );
				}else				// if( pOpc->bData != 0xFF )
				{

					pDism->Instruction.bIsModRM		= ((pOpc->bData == 0x10 ) || 
													(pOpc->bData >= 0 && pOpc->bData <= 7) );
					pDism->Instruction.Opcode		= pOpc;
					strcpy(	pDism->szAdditional,	NOT_IMPLEMENTED_YET);
					pDism->szInstruction			= pOpc->szName;
					
					if( pOpc->bImmSize != 0 )	// bImmSize has a value.
					{
						if( (pOpc->bImmSize >= JMP_BYTE && pOpc->bImmSize <= JMP_FAR) ||
							(pOpc->uArgs[ 0] == PTR16_16 || pOpc->uArgs[ 0] == PTR16_32 ) )
						{
							// Relative jumps
							DWORD	dwRel = 0;

							switch( pOpc->bImmSize )
							{
							case JMP_BYTE:
								dwRel = __GET_IMM( DWORD, pDism->dwInstrAddress, 
													GetOpcodeBytesNumber(pDism->Instruction.Opcode));
								if( CheckIfValueIsRelative( dwRel) )
								{
									sprintf( pDism->szParameters[ 0], "%02Xh", pDism->dwInstrAddress + dwRel );
									pDism->dwParameters[ 0] = pDism->dwInstrAddress + dwRel;
									dwRel = 0xFF - dwRel - 1;
									sprintf( pDism->szAdditional, "Relative: $%c%Xh", 
											((!IS_NEGATIVE(dwRel))? '+':'-' ), dwRel );
								}else
								{
									sprintf( pDism->szParameters[ 0], "%02Xh", dwRel );
									pDism->dwParameters[ 0] = dwRel;
									sprintf( pDism->szAdditional, "Relative: $%c%Xh", 
											((!IS_NEGATIVE(dwRel))? '+':'-' ), dwRel );
								}
								break;
							case JMP_WORD:
							case PTR16_16:
								dwRel = __GET_IMM( DWORD, pDism->dwInstrAddress, 
													GetOpcodeBytesNumber(pDism->Instruction.Opcode));
								sprintf( pDism->szParameters[ 0], "%04Xh", pDism->dwInstrAddress + dwRel );
								pDism->dwParameters[ 0] = pDism->dwInstrAddress + dwRel;
								if( 0xF000 & dwRel ) dwRel = 0xFFFF - dwRel - 2;
								sprintf( pDism->szAdditional, "Relative: $%c%Xh", 
										((!IS_NEGATIVE_WORD(dwRel))? '+':'-' ), dwRel );
								break;
							case JMP_DWORD:
							case PTR16_32:
							case JMP_FAR:
								dwRel = __GET_IMM( DWORD, pDism->dwInstrAddress, 
													GetOpcodeBytesNumber(pDism->Instruction.Opcode));
								sprintf( pDism->szParameters[ 0], "%08Xh", pDism->dwInstrAddress + dwRel );
								pDism->dwParameters[ 0] = pDism->dwInstrAddress + dwRel;
								if( 0xFF000000 & dwRel ) dwRel = 0xFFFFFFFF - dwRel - 4;
								sprintf( pDism->szAdditional, "Relative: $%c%Xh", 
										((!IS_NEGATIVE(dwRel))? '+':'-' ), dwRel );
								break;
							}			// switch( pOpc->bImmSize )

						}else
						{		// Not Relative Jump, but has Immediate Value (or MOFFS type). Parse it.
							for( unsigned u = 0; u < pOpc->uArgC; u++)
							{	
								if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_BYTE )
								{
									switch(pOpc->uArgs[ u] )
									{
									//case MOFFS8:
									case IMM8:
										{
											BYTE bImm = __GET_IMM( BYTE, pDism->dwInstrAddress,
														GetOpcodeBytesNumber(pDism->Instruction.Opcode));
											sprintf( pDism->szParameters[ u], "%Xh", bImm);
											pDism->dwParameters[ 0] = bImm;
										}
										break;
									default:
										{
											sprintf( pDism->szParameters[ u], "(N/A - dbg: uArgs[%d]=%X)",
													u, pOpc->uArgs[ u] );
											break;
										}

									} // switch
								}else if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_WORD )
								{
									switch(pOpc->uArgs[ u] )
									{
									//case MOFFS16:
									case IMM16:
										{
											WORD wImm = __GET_IMM( WORD, pDism->dwInstrAddress,
														GetOpcodeBytesNumber(pDism->Instruction.Opcode));
											sprintf( pDism->szParameters[ u], "%04Xh", wImm);
											pDism->dwParameters[ 0] = wImm;
										}
										break;
									default:
										{
											sprintf( pDism->szParameters[ u], "(N/A - dbg: uArgs[%d]=%X)",
													u, pOpc->uArgs[ u] );
											break;
										}

									} // switch

								}else if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_DWORD )
								{
									switch(pOpc->uArgs[ u] )
									{
									//case MOFFS32:
									case IMM32:
										{
											DWORD dwImm = __GET_IMM( DWORD, pDism->dwInstrAddress,
														GetOpcodeBytesNumber(pDism->Instruction.Opcode));
											sprintf( pDism->szParameters[ u], "%08Xh", dwImm);
											pDism->dwParameters[ 0] = dwImm;
										}
										break;
									default:
										{
											sprintf( pDism->szParameters[ u], "(N/A - dbg: uArgs[%d]=%X)",
													u, pOpc->uArgs[ u] );
											break;
										}

									} // switch
								}
								else if( IsRegister( pOpc->uArgs[ u]) )
									sprintf( pDism->szParameters[ u], GetRegister( pOpc->uArgs[ u] ) );

							}

						}
					}
					else		// bImmSize == 0
					{
						if( IsMoffsParamType(pOpc) )
							__PrepareDism( pOpc, &lpBuffer[uTmp-pDism->Instruction.NumOfPrefixes], pDism);
					}
				}			// else				// if( pOpc->bData != 0xFF )
			}			// if( pOpc->bData != 0xFF )
		}

		if( pDism->Instruction.NumOfBytes == 0)
			pDism->Instruction.NumOfBytes = 1;

		// Check for XRefs...
		_StaticInstrAnalysis( pDism, lpDisasm, uProcessedInstructions);
		

		uTmp			+= pDism->Instruction.NumOfBytes - pDism->Instruction.NumOfPrefixes;
		if( bCountInstructions )	uCounter ++;
		else						uCounter = uTmp;

		uProcessedInstructions	++;
		pDism					++;

	}	// while( uCounter < dwQuanity )

	_StaticAfterAnalysis( lpDisasm, uProcessedInstructions );

	if( _disasm::optAutoAnalyse )
		AnalyseDisasm( lpDisasm, uProcessedInstructions, _disasm::optAutoAnalysisFlags );

	return uProcessedInstructions;
}


////////####################################################################################
const char* 
		_disasm::GetRegister( unsigned uRegister )
{
	switch( uRegister)
	{
	case AL:return _AL;
	case CL:return _CL;
	case DL:return _DL;
	case BL:return _BL;
	case AH:return _AH;
	case CH:return _CH;
	case DH:return _DH;
	case BH:return _BH;

	case AX:return _AX;
	case CX:return _CX;
	case DX:return _DX;
	case BX:return _BX;
	case SP:return _SP;
	case BP:return _BP;
	case SI:return _SI;
	case DI:return _DI;
	case IP:return _IP;

	case EAX:return _EAX;
	case ECX:return _ECX;
	case EDX:return _EDX;
	case EBX:return _EBX;
	case ESP:return _ESP;
	case EBP:return _EBP;
	case ESI:return _ESI;
	case EDI:return _EDI;
	case EIP:return _EIP;

	case DR0:return _DR0;
	case DR1:return _DR1;
	case DR2:return _DR2;
	case DR3:return _DR3;
	case DR6:return _DR6;
	case DR7:return _DR7;
	case CR0:return _CR0;
	case CR2:return _CR2;
	case CR3:return _CR3;
	case CR4:return _CR4;

	default: return _UNKNOWN;
	}
}

const char*	
		_disasm::GetRegister( unsigned uIndex, short sSize )
{
	switch( sSize )
	{
	case SIZE_BYTE:
		switch( uIndex)
		{
		case 0:	return _AL;
		case 1: return _CL;
		case 2: return _DL;
		case 3: return _BL;
		case 4: return _AH;
		case 5: return _CH;
		case 6: return _DH;
		case 7: return _BH;
		}
		break;
	case SIZE_WORD:
		switch( uIndex)
		{
		case 0:	return _AX;
		case 1: return _CX;
		case 2: return _DX;
		case 3: return _BX;
		case 4: return _SP;
		case 5: return _BP;
		case 6: return _SI;
		case 7: return _DI;
		}
		break;
	case SIZE_DWORD:
		switch( uIndex)
		{
		case 0:	return _EAX;
		case 1: return _ECX;
		case 2: return _EDX;
		case 3: return _EBX;
		case 4: return _ESP;
		case 5: return _EBP;
		case 6: return _ESI;
		case 7: return _EDI;
		}
		break;
	}

	return _UNKNOWN;
}



////////####################################################################################
void	_disasm::__PrepareDism( _i386Opcode *pOpc, LPVOID _lpBuffer, PDISM pDism, bool bRegDependent  )
{
	_i386Instruction *pInstr	= &pDism->Instruction;
	pDism->dwInstrAddress		= (DWORD)_lpBuffer;

	BYTE	*lpBuffer			= (BYTE*)_lpBuffer;
	bool	bIsModRM			= IsModRM( pOpc);
	pInstr->Opcode				= pOpc;
	pInstr->bIsModRM			= bIsModRM;
	pInstr->NumOfPrefixes		= 0;

	short	nOpcBytes			= 0;		// Number of offset bytes, used while locating bytes.
											//	Include ModRM and SIB byte shift	
	for( unsigned u = 0; u < 4; u ++ )		// Iterating on prefixes, searching num of prefixes
		if( IsPrefix( (BYTE)lpBuffer[ u] ) )
		{
			_i386Prefixes	*prfx = GetPrefix( (BYTE)lpBuffer[ u]);
			pInstr->Prefixes[ pInstr->NumOfPrefixes]->bCode		= prfx->bCode;
			pInstr->Prefixes[ pInstr->NumOfPrefixes]->bGroup	= prfx->bGroup;
			pInstr->Prefixes[ pInstr->NumOfPrefixes]->szName	= prfx->szName;
			strncpy(	pDism->szPrefixes[ pInstr->NumOfPrefixes], 
						prfx->szName, sizeof pDism->szPrefixes[ 0] );
			pInstr->NumOfPrefixes ++;
		}

	// Determining size of opcode bytes to shift offset
	nOpcBytes		= GetOpcodeBytesNumber( pInstr->Opcode );
	nOpcBytes		+= pInstr->NumOfPrefixes;
	unsigned uTmp	= 0;
	
	union {
		BYTE b;
		_i386ModRM mod;
	};
	union { 
		BYTE		bSib;
		_i386SIB	sib;
	};

	if( bIsModRM )
	{
		b = (BYTE)lpBuffer[ nOpcBytes++ ];	
		memcpy( (void*)&pInstr->s.ModRM, (const void*)&b, sizeof b);

		if( mod.RM == 4)
		{
			bSib = (BYTE)lpBuffer[ nOpcBytes++ ];
			uTmp ++;					// Increment SIB byte
			memcpy( (void*)&pInstr->s.SIB, (const void*)&bSib, sizeof bSib);
		}
	}

	char	szTmp1[ 35] = "";
	char	szTmp2[ 35] = "";

	if( bRegDependent )
	{
		_i386Opcode *_pOpc = pOpc;
		bIsModRM = true;
		BYTE bReg = BYTE(*lpBuffer) - pOpc->bCode[0];
		mod.RegOp = bReg;
		mod.Mod = 3;
		mod.RM = 5;
	}

	// Iterating on opcode's operands
	for( unsigned u = 0; u < pOpc->uArgC; u++)
	{
		memset( pDism->szParameters[ u], 0, sizeof pDism->szParameters[ u] );

		if( 0 != pOpc->uArgs[ u] )						// If type of this operand is not NONE
		{
			if( GET_UNIT( pOpc->uArgs[ u] ) == 0 )		// Parameter is R_MX type - where X is a size
			{
				// A X-size general-purpose register, or a doubleword memory operand. 
				if( bIsModRM )
				{
					if( mod.RM == 4)						// SIB/ESP
					{
						if( mod.Mod == 3)
							sprintf( szTmp1, "%s", GetRegister( mod.RegOp, GET_SIZE( pOpc->uArgs[ u]) ) );
						else
						{
							bool	bIsBase = !(mod.Mod == 0 && sib.Base == 5);
							char	szScale[3] = "";
							char	szDisp[ 12] = "";
							DWORD	dwDisp;					// Displacement
							
							if( mod.Mod == 1){ 
								dwDisp = __GET_IMM( BYTE, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
								uTmp += SIZE_BYTE / 8; 
							}
							else/* if( mod.Mod == 2)*/{ 
								dwDisp = __GET_IMM( DWORD, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
								uTmp += SIZE_DWORD / 8; 
							}

							sprintf(szScale, "%d", (BYTE)pow(2, (double)sib.Scale) );
							sprintf(szDisp, "0x%08X", dwDisp );

															//			B + I * S + dispXX == 7
							sprintf_s( szTmp1, sizeof szTmp1, "%s%s%s%s%s%s%s", 
									((bIsBase)? GetRegister(sib.Base, GET_SIZE(pOpc->uArgs[ u])) : ""),
									((bIsBase)? " + " : "" ),
									(GetRegister(sib.Index, GET_SIZE(pOpc->uArgs[ u])) ),
									((sib.Scale != 0 )? "*" : "" ),
									((sib.Scale != 0 )? szScale : "" ),
									(((mod.Mod == 0 && sib.Base == 5) || mod.Mod == 2 || mod.Mod == 3)?
									" + " : "" ), 
									(((mod.Mod == 0 && sib.Base == 5) || mod.Mod == 2 || mod.Mod == 3)?
									szDisp : "" )
							);
						}
					}else if( mod.RM == 5)							// +disp32/EBP
					{
						if( mod.Mod == 1 )
						{
							// mod.Mod == 1 (disp8) and mod.RM == 5 (disp32/EBP) so use EBP
							BYTE bRel = __GET_IMM( BYTE, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
							sprintf( szTmp1, "%s%c%Xh", _EBP, (IS_NEGATIVE(bRel)? '-':'+'), 
									byteComputeAlignment(bRel) );

							uTmp ++;
						}
						else
						{
							uTmp = 0;
							if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_BYTE ){
								sprintf( szTmp1, ((!_disasm::optUseDecimal)? "%02Xh":"%d"),
										__GET_IMM( BYTE, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
								pDism->dwParameters[ 0] = __GET_IMM( BYTE, 
															(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
								uTmp += SIZE_BYTE / 8;
							}
							else if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_WORD ){
								sprintf( szTmp1, ((!_disasm::optUseDecimal)? "%04Xh":"%d"),
										__GET_IMM( WORD, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
								pDism->dwParameters[ 0] = __GET_IMM( WORD, 
									(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
								uTmp += SIZE_WORD / 8;
							}
							else /* if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_DWORD )*/{
								sprintf( szTmp1, ((!_disasm::optUseDecimal)? "%08Xh":"%d"),
										__GET_IMM( DWORD, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
								pDism->dwParameters[ 0] = __GET_IMM( DWORD, 
									(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
								uTmp += SIZE_DWORD / 8;
							}
							//else sprintf( szTmp1, "??" );
						}

					}else if( mod.Mod == 1)
					{
						// Mod=1 - [REG + disp8 ]
						BYTE bDisp8 = __GET_IMM( BYTE, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp );
						sprintf( szTmp1, "%s%c%X", GetRegister( mod.RM, GET_SIZE(pOpc->uArgs[ u])), 
								(IS_NEGATIVE( bDisp8)? '-':'+'), bDisp8);
						pDism->dwParameters[ 0] = bDisp8;
						uTmp ++;
					}
					else							// ModRM.Mod is not SIB, so ordinary register is in use
						if( GET_UNIT(pOpc->uArgs[u]) == 1 )			// RX type
							sprintf( szTmp1, "%s", GetRegister( mod.RegOp, GET_SIZE( pOpc->uArgs[ u]) ) );
						else if( GET_UNIT( pOpc->uArgs[u]) == 0 )	// R_MX type
							sprintf( szTmp1, "%s", GetRegister( mod.RM, GET_SIZE( pOpc->uArgs[u]) ) );

					if( mod.Mod != 3)
					{
						sprintf( szTmp2, "[%s]", szTmp1);
						strcpy( szTmp1, szTmp2);

						if( pInstr->NumOfPrefixes != 0)			// Applying prefixes
							for( unsigned u1 = 0; u1 < pInstr->NumOfPrefixes; u1++)
								if( pInstr->Prefixes[ u1] != NULL )
									if( pInstr->Prefixes[ u1]->bGroup == 2){
										sprintf( szTmp2, "%s:%s", pInstr->Prefixes[ u1]->szName, 
												szTmp1 );
										strcpy( szTmp1, szTmp2);
										break;
									}
					}
				}
				else			// Instruction has not ModRM byte
				{
					if( IsRegister( pOpc->uArgs[ u] ) )
						sprintf( szTmp1, "%s", GetRegister( pOpc->uArgs[ u]) );
					else
						__asm	nop
				}
			}
			else if( GET_UNIT( pOpc->uArgs[ u] ) == 1 )	// Parameter is RX type - where X is a size
			{
				sprintf( szTmp1, "%s", GetRegister( mod.RegOp, GET_SIZE( pOpc->uArgs[ u]) ) );
			}
			else if( GET_UNIT( pOpc->uArgs[ u] ) == 2 )	// Parameter is IMMX type - where X is a size
			{
				if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_BYTE ){
					sprintf( szTmp1, ((!_disasm::optUseDecimal)? "%02Xh":"%d"), __GET_IMM( BYTE, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );					
					pDism->dwParameters[ 0] = __GET_IMM( BYTE, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
					uTmp += SIZE_BYTE / 8; 
				}
				else if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_WORD ){
					sprintf( szTmp1, ((!_disasm::optUseDecimal)? "%04Xh":"%d"), __GET_IMM( WORD, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
					pDism->dwParameters[ 0] = __GET_IMM( WORD, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
					uTmp += SIZE_WORD / 8; 
				}
				else{	sprintf( szTmp1, ((!_disasm::optUseDecimal)? "%08Xh":"%d"), __GET_IMM( DWORD, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
						pDism->dwParameters[ 0] = __GET_IMM( DWORD, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
						uTmp += SIZE_DWORD / 8; 
				}
			}
			else if( GET_UNIT( pOpc->uArgs[ u] ) == 3 )	// Parameter is MX type - where X is a size
			{
				// In base of this value, you will have to append correct character
				// to opcode's name, like when your opcode's name will be "INS", and
				// this size will be 8 - BYTE, correct name of this mnemonic will be "INSB".
				// And then you will have to assign this problematic character.

				pInstr->Opcode->bImmSize = GET_SIZE( pOpc->uArgs[ u]);
			}
			else if( GET_UNIT( pOpc->uArgs[ u] ) == 4 )	// Parameter is MoffsX type - where X is a size
			{
				char	*szSegName = NULL;
				for( unsigned u1 = 0; u1 < pInstr->NumOfPrefixes; u1++)
					if( pInstr->Prefixes[ u1]->bGroup == 2){
						szSegName = pInstr->Prefixes[ u1]->szName;
						break;
					}
				if( szSegName == NULL) szSegName = st_globalPrefixes[5].szName;

				if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_BYTE ){
					sprintf( szTmp1, "%s:[%Xh]", szSegName, __GET_IMM( BYTE, 
											(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
					pDism->dwParameters[ 0] = __GET_IMM( BYTE, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
					uTmp += SIZE_BYTE / 8;
				}
				else if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_WORD ){
					sprintf( szTmp1, "%s:[%Xh]", szSegName, __GET_IMM( WORD, 
											(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
					pDism->dwParameters[ 0] = __GET_IMM( WORD, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
					uTmp += SIZE_WORD / 8;
				}
				else /* if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_DWORD )*/{
					sprintf( szTmp1, "%s:[%Xh]", szSegName, __GET_IMM( DWORD, 
											(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
					pDism->dwParameters[ 0] = __GET_IMM( DWORD, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp );
					uTmp += SIZE_DWORD / 8;
				}
				//else sprintf( szTmp1, "??" );
			}
			else if( GET_UNIT( pOpc->uArgs[ u] ) == 5 )	// Parameter is RELX type - where X is a size
			{
				if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_BYTE )
				{
					sprintf( szTmp1, "%02Xh", pDism->dwInstrAddress + 
							__GET_IMM(BYTE, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
					pDism->dwParameters[ 0] = pDism->dwInstrAddress + __GET_IMM( BYTE, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
					uTmp += SIZE_BYTE / 8;
				}
				else if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_WORD )
				{
					sprintf( szTmp1, "%04Xh", pDism->dwInstrAddress + 
							__GET_IMM(WORD, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
					pDism->dwParameters[ 0] = pDism->dwInstrAddress + __GET_IMM( WORD, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
					uTmp += SIZE_WORD / 8;
				}
				else /* if( GET_SIZE( pOpc->uArgs[ u]) == SIZE_DWORD )*/
				{
					sprintf( szTmp1, "%08Xh", pDism->dwInstrAddress + 
							__GET_IMM(DWORD, (LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp) );
					pDism->dwParameters[ 0] = pDism->dwInstrAddress + __GET_IMM( DWORD, 
										(LPVOID)(DWORD(_lpBuffer)+nOpcBytes), uTmp);
					uTmp += SIZE_DWORD / 8;
				}//else sprintf( szTmp1, "??" );
			}
			else if( pOpc->uArgs[ u] == 0x26 )			// SegmentREG
			{
				if( mod.RegOp == 0 )		strcpy( szTmp1, _ES );
				else if( mod.RegOp == 1 )	strcpy( szTmp1, _CS );
				else if( mod.RegOp == 2 )	strcpy( szTmp1, _SS );
				else if( mod.RegOp == 3 )	strcpy( szTmp1, _DS );
				else if( mod.RegOp == 4 )	strcpy( szTmp1, _FS );
				else if( mod.RegOp == 5 )	strcpy( szTmp1, _GS );
				else						strcpy( szTmp1, _UNKNOWN );
			}
			else	sprintf( szTmp1, "?? (operand %Xh - %01d:%01d)", pOpc->uArgs[ u],
							GET_BASE( pOpc->uArgs[ u]), GET_UNIT(pOpc->uArgs[ u]) );
		
			strncpy( pDism->szParameters[ u], szTmp1, sizeof pDism->szParameters[ u]-1 );

		}			// if( 0 != pOpc->uArgs[ u] )
	}			// for( unsigned u = 0; u < pOpc->uArgC; u++)	
	
	if( nOpcBytes > 15 ) nOpcBytes = 15;
	if( nOpcBytes == 0 ) nOpcBytes = 1;
	pInstr->NumOfBytes = (BYTE)(nOpcBytes + uTmp);
	memcpy( (void*)pInstr->cInstrBytes, (const void*)lpBuffer, pInstr->NumOfBytes );

	// Truely preparing DISM code.
	pDism->szInstruction = pOpc->szName;	// Name
	strcpy( pDism->szAdditional, NOT_IMPLEMENTED_YET);

}


////////####################################################################################

unsigned 
		_disasm::GetInstrBytesQuanity( LPVOID _lpBuffer )
{	
	LPBYTE		lpBuffer	= (LPBYTE)_lpBuffer;
	_i386Opcode *pOpc		= GetOpcodeEx( lpBuffer);

	if( pOpc == NULL){
		if( IsRegDependent( lpBuffer[ 0] ) )
			if( lpBuffer[0] == 0x0F )pOpc =  GetOpcode( 0x0F, 0xC8);// 0F C8+rd instruction BSWAP exception
			else{													// Rest of reg-dependent instruction
				unsigned u;
				for( u = 0; u < 8; u++ )
					if( GetOpcode( lpBuffer[0] - u) != NULL)
						if( GetOpcode( lpBuffer[0] - u)->bData == 0x50 ) break;

				pOpc = GetOpcode( lpBuffer[0]-u );
			}
		else{
			if( IsEscape( (BYTE)lpBuffer[ 0] ) )	pOpc = GetOpcode( lpBuffer[1] );
			else									pOpc = GetOpcode( lpBuffer[0], lpBuffer[ 1] );
			_ASSERT( pOpc != NULL );
		}

		if( pOpc == NULL) pOpc = GetOpcodeEx( (LPBYTE)_lpBuffer );
	}

	unsigned	uNumOfBytes = GetOpcodeBytesNumber( pOpc);
	unsigned	uImmSize	= 0;

	_i386ModRM _Mod;

	if( (pOpc->bData >= 0 && pOpc->bData <= 7) || pOpc->bData == 0x10 )
		memcpy( (void*)&_Mod, (const void*)&(lpBuffer[ 1 ]), sizeof _Mod);		// ModRM.Mod

	// Searching for largest immediate used...
	for( unsigned u = 0; u < pOpc->uArgC; u++)
	{
		unsigned g = GET_UNIT( pOpc->uArgs[ u]);
		if( g == 2 || g == 4 || g == 5 )	uImmSize += GET_SIZE( pOpc->uArgs[ u]) / 8;
		else if( g == 0 && (pOpc->bData >= 0 && pOpc->bData <= 7) || pOpc->bData == 0x10 ){
			// Have ModR/M
			if( _Mod.Mod == 1) uImmSize += 1;
			else if( _Mod.Mod == 2) uImmSize += 4;
			break;
		}
	}	// for


	if( (pOpc->bData >= 0 && pOpc->bData <= 7) || pOpc->bData == 0x10 )
	{
		// ModR/M or Group exists.
		uNumOfBytes ++;
		BYTE Mod = (lpBuffer[ GetOpcodeBytesNumber( pOpc) ] & 0xC0);		// ModRM.Mod

		if( _Mod.RM == 4 && _Mod.Mod < 3 ){	// There is a SIB byte
			uNumOfBytes ++;

			if( _Mod.Mod == 1 ) uNumOfBytes ++;				// +disp8
			else if( _Mod.Mod == 2) uNumOfBytes += 4;		// +disp32
		}else
		{
			for( unsigned u = 0; u < pOpc->uArgC; u++)
				if( (GET_UNIT(pOpc->uArgs[u]) >= 0 && GET_UNIT(pOpc->uArgs[u]) < 6)
					&& GET_UNIT(pOpc->uArgs[u]) != 1 )
					// Opcode has ModRM byte but ModRM.Mod == 0 (probably) thus
					// have to choose alternative method of computing bytes quanity
						if( !(uNumOfBytes > (GetOpcodeBytesNumber( pOpc) + 1 /* for ModRM */) )  )
							uNumOfBytes += GET_BASE( pOpc->uArgs[ u]);
		}
	}
	
	uNumOfBytes += uImmSize;

	return uNumOfBytes;
}


////////####################################################################################

IMPORTED_FUNCTION *
		_disasm::CheckIfCallToImport ( DWORD dwRel, bool bIsRelative)
{

	DWORD dwTmp = dwRel;
	if( bIsRelative) 
		dwRel = peFile.RVA2RAW(_disasm::dwordComputeAlignment( dwRel));

	if( dwRel == 0) return NULL;

	for( unsigned u = 0; u < peFile.vImports.size(); u++)
	{
		IMPORTED_FUNCTION	imp = peFile.vImports[ u];
		if( imp.dwThunkRVA == dwTmp )
			return &peFile.vImports[ u];
	}

	return NULL;
}



////////####################################################################################

unsigned	
		_disasm::__DisassembleAsData	( LPVOID _lpBuffer, PDISM lpDism, 
										unsigned uNumOfBytes, DWORD dwRel, bool bForceBytes )
{
	LPBYTE		lpBuffer	= (BYTE*)_lpBuffer;
	unsigned	uProcessed	= 0,
				uTmp		= 0;
	bool		bParseForward = false;
	unsigned	toParse		= uNumOfBytes;

	if( uNumOfBytes > 10 && !bForceBytes)
	{
		// Parse bytes as DDs
		bParseForward	= false;
		unsigned u		= 0;

		for( u = 0; u < (uNumOfBytes-4); u += 4)
		{
			lpDism->dwInstrAddress				= DWORD(lpBuffer) + DWORD( u );
			lpDism->dwRelativeAddr				= dwRel + u;
			lpDism->Instruction.bIsModRM		= false;
			lpDism->Instruction.cInstrBytes[0]	= (BYTE)lpBuffer[ u];
			lpDism->Instruction.cInstrBytes[1]	= (BYTE)lpBuffer[ u+1];
			lpDism->Instruction.cInstrBytes[2]	= (BYTE)lpBuffer[ u+2];
			lpDism->Instruction.cInstrBytes[3]	= (BYTE)lpBuffer[ u+3];
			lpDism->Instruction.NumOfBytes		= 4;
			lpDism->Instruction.NumOfPrefixes	= 0;
			lpDism->Instruction.Opcode			= (_disasm::GetOpcode( 0xFF, 0xFF));	// DD opcode
			lpDism->Instruction.wNOP			= 0;
			lpDism->szInstruction				= lpDism->Instruction.Opcode->szName;

			DWORD	*dwParam = (DWORD*)(DWORD(lpBuffer)+u);
			sprintf( lpDism->szParameters[0], "%08Xh", *dwParam );

			uProcessed++;
			lpDism++;
		}

		if( (u) < uNumOfBytes ){
			toParse = uNumOfBytes - u;
			bParseForward = true;
		}
	}else
		bParseForward = true;

	if( bParseForward )
	{
		unsigned uT = 0;
		if( uProcessed )	uT = uProcessed-1;
		else				uT = dwRel;

		// Parse rest of bytes as DBs
		for( unsigned u1 = 0; u1 < toParse; u1 ++)
		{
			lpDism->dwInstrAddress				= DWORD(lpBuffer) + DWORD( u1 );
			lpDism->dwRelativeAddr				= uT + u1;
			lpDism->Instruction.bIsModRM		= false;
			lpDism->Instruction.cInstrBytes[0]	= lpBuffer[ u1];
			lpDism->Instruction.NumOfBytes		= 1;
			lpDism->Instruction.NumOfPrefixes	= 0;
			lpDism->Instruction.Opcode			= (_disasm::GetOpcode( 0xFF, 0xFD));	// DB opcode
			lpDism->Instruction.wNOP			= 0;
			lpDism->szInstruction				= lpDism->Instruction.Opcode->szName;
			sprintf( lpDism->szParameters[0], "%02Xh", lpDism->Instruction.cInstrBytes[0] );
			memset( lpDism->szPrefixes, 0, sizeof( lpDism->szPrefixes ));

			uProcessed++;
			lpDism++;
		}
	}

	return uProcessed;
}

////////####################################################################################

bool	_disasm::IsJump ( _i386Opcode *pOpc)
{
	unsigned n = __JUMPCODES1_ARRAY_SIZE;
	for( unsigned u = 0; u < n; u++)
		if( pOpc->bCode[ 0] == st_globalJumpCodes1[ u] )
			return true;

	n = __JUMPCODES2_ARRAY_SIZE;
	for( unsigned u = 0; u < n; u++)
		if( pOpc->bCode[ 0] == st_globalJumpCodes2[ u][0] &&
			pOpc->bCode[ 1] == st_globalJumpCodes2[ u][1])
			return true;
	
	if( pOpc->bCode[ 0] == 0xFF && (pOpc->bData == 0x04 || pOpc->bData == 0x10) )
		return true;

	return false;
}


////////####################################################################################

void	_disasm::AnalyseDisasm		(	LPDISM	lpDisasm, unsigned long uNumOfInstr, DWORD dwFlags )
{

	for( unsigned u = 0; u < uNumOfInstr; u++)
	{
		if( dwFlags & ANALYSE_CALLING_IMPORTS )
		{
			if( lpDisasm[u].Analysis.bIsReferencing )
			{
				IMPORTED_FUNCTION *imp = CheckIfCallToImport( lpDisasm[u].dwParameters[0]);
				if( imp != NULL)
				{
					sprintf_s( lpDisasm[u].szAdditional, sizeof( lpDisasm[u].szAdditional),
								"%s", imp->szFunction );
				}
			}
		}
		else if( dwFlags & ANALYSE_IMPORTS_IN_PARAMS )
		{
			IMPORTED_FUNCTION *imp;
			for( unsigned i = 0; i < 3; i++)
			{
				imp = CheckIfCallToImport( lpDisasm[u].dwParameters[i]);
				if( imp != NULL) break;
			}

			if( imp != NULL)
			{
				sprintf_s( lpDisasm[u].szAdditional, sizeof( lpDisasm[u].szAdditional),
							"%s", imp->szFunction );
			}
		}
	}



	return;
}



////////####################################################################################

void	_disasm::_StaticInstrAnalysis	( LPDISM lpInstruction, LPDISM lpWholeSet, 
										unsigned nSetCapacity )
{

	memset( (void*)(&lpInstruction->Analysis), 0, sizeof( lpInstruction->Analysis) );

	if( lpInstruction->Instruction.Opcode == NULL)
		return;

	// Check if this instruction is referencing another (CALL/JUMP):
	if( IsCall( lpInstruction->Instruction.Opcode ) ){
		lpInstruction->Analysis.bIsReferencing = true;
		lpInstruction->Analysis.ThisXRef.dwDstAddr = lpInstruction->dwParameters[0];
		lpInstruction->Analysis.ThisXRef.dwSrcAddr = lpInstruction->dwInstrAddress;
		lpInstruction->Analysis.ThisXRef.dwType = XREF_TYPE_CALL;
		lpInstruction->Analysis.ThisXRef.Instruction = lpInstruction;
	}else if( IsJump( lpInstruction->Instruction.Opcode ) ){
		lpInstruction->Analysis.bIsReferencing = true;
		lpInstruction->Analysis.ThisXRef.dwDstAddr = lpInstruction->dwParameters[0];
		lpInstruction->Analysis.ThisXRef.dwSrcAddr = lpInstruction->dwInstrAddress;
		lpInstruction->Analysis.ThisXRef.dwType = 
			(IsConditionalJump(lpInstruction->Instruction.Opcode))? 
				XREF_TYPE_CJUMP : XREF_TYPE_JUMP;
		lpInstruction->Analysis.ThisXRef.Instruction = lpInstruction;
	}/*else if( )
	 {
		// Check if it is referencing another instr. by memory referencing

	 }
	 */

	if( lpInstruction->Analysis.bIsReferencing )
	{
		// Searching for target of XRef
		register unsigned ru = 0;
		for( ru = 0; ru < nSetCapacity; ru++)
			if( lpWholeSet[ ru].dwInstrAddress == lpInstruction->Analysis.ThisXRef.dwDstAddr )
			{
				lpWholeSet[ ru].Analysis.bIsReferenced = true;
				lpWholeSet[ ru].Analysis.vXRefsTo.push_back( lpInstruction->Analysis.ThisXRef);
				lpWholeSet[ ru].Analysis.uNumOfXRefsTo++;
				break;
			}
	}

	return;
}


////////####################################################################################

void	_disasm::_StaticAfterAnalysis ( LPDISM lpDisasm, unsigned nSetCapacity )
{
	LPDISM lpInstruction;

	for( unsigned n = 0; n < nSetCapacity; n++)
	{
		lpInstruction = &lpDisasm[n];
		if( lpInstruction->Analysis.bIsReferenced )
		{
			unsigned uC = 0;
			DWORD dwTmp = 0;

			for( unsigned u = 0; u < lpInstruction->Analysis.vXRefsTo.size(); u++)
			{
				if( lpInstruction->Analysis.vXRefsTo[ u].dwDstAddr 
					== lpInstruction->dwInstrAddress){
					uC ++;
					dwTmp = lpInstruction->Analysis.vXRefsTo[ u].dwSrcAddr;
				}
			}

			if( uC == 1)
				sprintf( lpInstruction->szAdditional, "XRef from %08X", dwTmp );
			else sprintf( lpInstruction->szAdditional, "%d XRefs to this instruction", uC );
		}
	}
}